<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>quartz实现原理 | quiterr的个人博客</title>
    <meta name="description" content="quiterr的个人博客">
    <link rel="icon" href="/assets/img/logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2fd3a0e5.css" as="style"><link rel="preload" href="/assets/js/app.d45e7d8d.js" as="script"><link rel="preload" href="/assets/js/3.f201c9f2.js" as="script"><link rel="preload" href="/assets/js/2.58f2d4b3.js" as="script"><link rel="preload" href="/assets/js/12.5d5dd355.js" as="script"><link rel="prefetch" href="/assets/js/10.8f6ff41b.js"><link rel="prefetch" href="/assets/js/11.d3060e6c.js"><link rel="prefetch" href="/assets/js/13.b58b39cd.js"><link rel="prefetch" href="/assets/js/14.132da01d.js"><link rel="prefetch" href="/assets/js/15.4de3abff.js"><link rel="prefetch" href="/assets/js/16.5d01f151.js"><link rel="prefetch" href="/assets/js/17.743cc240.js"><link rel="prefetch" href="/assets/js/18.5cd47213.js"><link rel="prefetch" href="/assets/js/19.c31513f4.js"><link rel="prefetch" href="/assets/js/20.ff0c8b17.js"><link rel="prefetch" href="/assets/js/21.23bfd343.js"><link rel="prefetch" href="/assets/js/22.7b1bcdc8.js"><link rel="prefetch" href="/assets/js/23.9aa9bcc6.js"><link rel="prefetch" href="/assets/js/24.41feae7a.js"><link rel="prefetch" href="/assets/js/25.085c0a62.js"><link rel="prefetch" href="/assets/js/26.28112f5e.js"><link rel="prefetch" href="/assets/js/27.3dfa1162.js"><link rel="prefetch" href="/assets/js/28.64b59646.js"><link rel="prefetch" href="/assets/js/29.5da0daa7.js"><link rel="prefetch" href="/assets/js/30.e061c642.js"><link rel="prefetch" href="/assets/js/31.af9d5f01.js"><link rel="prefetch" href="/assets/js/32.3bb3cd16.js"><link rel="prefetch" href="/assets/js/33.28c6384b.js"><link rel="prefetch" href="/assets/js/34.e24d72db.js"><link rel="prefetch" href="/assets/js/35.066a2949.js"><link rel="prefetch" href="/assets/js/36.3605469b.js"><link rel="prefetch" href="/assets/js/37.0f0334ec.js"><link rel="prefetch" href="/assets/js/38.c4e1f427.js"><link rel="prefetch" href="/assets/js/39.bf835b74.js"><link rel="prefetch" href="/assets/js/4.130bd99d.js"><link rel="prefetch" href="/assets/js/40.df4753ea.js"><link rel="prefetch" href="/assets/js/41.c0060482.js"><link rel="prefetch" href="/assets/js/42.13e0dffa.js"><link rel="prefetch" href="/assets/js/43.2a7ba197.js"><link rel="prefetch" href="/assets/js/44.4a50ce9b.js"><link rel="prefetch" href="/assets/js/45.04e3bb01.js"><link rel="prefetch" href="/assets/js/46.f860615e.js"><link rel="prefetch" href="/assets/js/47.57f7e152.js"><link rel="prefetch" href="/assets/js/48.c9adb86a.js"><link rel="prefetch" href="/assets/js/49.89d283b4.js"><link rel="prefetch" href="/assets/js/5.bc8341b3.js"><link rel="prefetch" href="/assets/js/50.176d29a8.js"><link rel="prefetch" href="/assets/js/51.73ee13f6.js"><link rel="prefetch" href="/assets/js/6.5dc22b3f.js"><link rel="prefetch" href="/assets/js/7.5d9116e6.js"><link rel="prefetch" href="/assets/js/8.ab4e4f3e.js"><link rel="prefetch" href="/assets/js/9.05f51b5b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2fd3a0e5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/logo.png" alt="quiterr的个人博客" class="logo"> <span class="site-name can-hide">quiterr的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://www.jianshu.com/u/e268fe04200a" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/quiterr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://www.hanclouds.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  hanclouds
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://www.jianshu.com/u/e268fe04200a" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/quiterr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://www.hanclouds.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  hanclouds
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/architecture/" class="sidebar-heading clickable"><span>架构设计</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/source/" class="sidebar-heading clickable router-link-active open"><span>源码阅读</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/source/netty/" class="sidebar-heading clickable"><span>netty源码学习</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/source/jdk/" class="sidebar-heading clickable"><span>jdk源码阅读</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/source/quartz" class="sidebar-heading clickable router-link-exact-active router-link-active open"><span>quartz源码阅读</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/source/quartz/" class="active sidebar-link">quartz实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/source/quartz/#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/source/quartz/#scheduler创建过程" class="sidebar-link">Scheduler创建过程</a></li><li class="sidebar-sub-header"><a href="/source/quartz/#scheduler启动过程" class="sidebar-link">Scheduler启动过程</a></li><li class="sidebar-sub-header"><a href="/source/quartz/#节点故障的处理" class="sidebar-link">节点故障的处理</a></li><li class="sidebar-sub-header"><a href="/source/quartz/#quartzschedulerthread线程" class="sidebar-link">QuartzSchedulerThread线程</a></li><li class="sidebar-sub-header"><a href="/source/quartz/#misfirehandler线程" class="sidebar-link">MisfireHandler线程</a></li></ul></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/design-pattern/" class="sidebar-heading clickable"><span>设计模式</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/frontend/" class="sidebar-heading clickable"><span>前端开发</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/database/" class="sidebar-heading clickable"><span>数据库</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/collection/" class="sidebar-heading clickable"><span>资料收藏</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="quartz实现原理"><a href="#quartz实现原理" class="header-anchor">#</a> quartz实现原理</h1> <p></p><div class="table-of-contents"><ul><li><a href="#概述">概述</a></li><li><a href="#scheduler创建过程">Scheduler创建过程</a></li><li><a href="#scheduler启动过程">Scheduler启动过程</a></li><li><a href="#节点故障的处理">节点故障的处理</a></li><li><a href="#quartzschedulerthread线程">QuartzSchedulerThread线程</a></li><li><a href="#misfirehandler线程">MisfireHandler线程</a></li></ul></div><p></p> <p>学到的知识：类.this，如何用mysql来做高可用</p> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p>在看源码分析实现原理之前，肯定要写一个demo来试用下quartz，也方便后续debug调试：<a href="https://github.com/quiterr/quartz-test" target="_blank" rel="noopener noreferrer">a quartz example<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>试过example之后，对基本概念有认识了，一图胜千言，借用一下别人的图：</p> <p><img src="/assets/img/1.1d6de726.png" alt=""></p> <p>开源框架的源码一般都很多，逐行去看显然不现实，所以尝试带着问题去看关键业务代码。</p> <p>尝试列一些问题：</p> <ul><li>问题1：quartz支持单机部署和集群部署，单机是内存存储（RAMJobStore），集群是数据库存储（对应DefaultClusteredJobStore），在哪里判断区分的？</li> <li>问题2：我们平常访问数据库会用mybatis之类的orm框架，quartz用的什么，它的sql在哪里？</li> <li>问题3：jdk做定时任务用的堆这种数据结构，线程模型用的leader-follower；netty的数据结构用的HashedWheelTimer，线程模型是单线程轮询+线程池处理任务；那么quartz用什么数据结构、线程模型？</li> <li>问题4：悲观锁是如何实现的？</li> <li>问题5：quartz集群的高可用如何实现的？</li> <li>问题6：节点如何分配任务？</li></ul> <h2 id="scheduler创建过程"><a href="#scheduler创建过程" class="header-anchor">#</a> Scheduler创建过程</h2> <p>下面是源码阅读了，我看的是quartz 2.3.0版本。在example的主类MyApp中有：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Scheduler</span> scheduler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StdSchedulerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从这里跟进去，很容易找到StdSchedulerFactory的instantiate()方法负责创建scheduler。这个方法大概800行，我直接拉到最后，倒着找，在1325行找到：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Scheduler</span> scheduler <span class="token operator">=</span> <span class="token function">instantiate</span><span class="token punctuation">(</span>rsrcs<span class="token punctuation">,</span> qs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>跟进去后是：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">Scheduler</span> <span class="token function">instantiate</span><span class="token punctuation">(</span><span class="token class-name">QuartzSchedulerResources</span> rsrcs<span class="token punctuation">,</span> <span class="token class-name">QuartzScheduler</span> qs<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token class-name">Scheduler</span> scheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StdScheduler</span><span class="token punctuation">(</span>qs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> scheduler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个代码有点扯了，rsrcs作为参数传进去但并没有使用，而且多看点源码就知道QuartzSchedulerResources的变量一般都命名为qsrcs，是不是命名也有误？</p> <p>不管怎样，现在知道何时创建Scheduler了。回到1325行，rsrcs是QuartzSchedulerResources类型，而我提前已经知道QuartzSchedulerResources这个类很关键了（因为看过这篇文章<a href="https://tech.meituan.com/2014/08/31/mt-crm-quartz.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2014/08/31/mt-crm-quartz.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p> <p>干脆把1325前面几行也贴出来：</p> <div class="language-java extra-class"><pre class="language-java"><code>rsrcs<span class="token punctuation">.</span><span class="token function">setJobStore</span><span class="token punctuation">(</span>js<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// add plugins</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> plugins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rsrcs<span class="token punctuation">.</span><span class="token function">addSchedulerPlugin</span><span class="token punctuation">(</span>plugins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

qs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QuartzScheduler</span><span class="token punctuation">(</span>rsrcs<span class="token punctuation">,</span> idleWaitTime<span class="token punctuation">,</span> dbFailureRetry<span class="token punctuation">)</span><span class="token punctuation">;</span>
qsInited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment">// Create Scheduler ref...</span>
<span class="token class-name">Scheduler</span> scheduler <span class="token operator">=</span> <span class="token function">instantiate</span><span class="token punctuation">(</span>rsrcs<span class="token punctuation">,</span> qs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里QuartzScheduler实现的是RemotableQuartzScheduler，我们用的StdScheduler实现的是Scheduler接口。这两个的区别借用网上找的一段话来解释：</p> <blockquote><p>调度器（Scheduler）是Quartz框架的心脏，用来管理触发器和Job，并保证Job能被触发执行。程序员与框架内部之间的调用都是通过org.quartz.Scheduler接口来完成的。对于Scheduler接口的实现，其实只是核心调度（org.quartz.core.QuartzScheduler）的一个代理，对代理的方法进行调用时会传递到底层核心调度实例上。QuartzScheduler处于Quartz框架的根位置，驱动着整个Quartz框架。</p></blockquote> <p>继续往上找js是哪里创建的，在1263行：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>js <span class="token keyword">instanceof</span> <span class="token class-name">JobStoreSupport</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">JobStoreSupport</span> jjs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JobStoreSupport</span><span class="token punctuation">)</span>js<span class="token punctuation">;</span>
    jjs<span class="token punctuation">.</span><span class="token function">setDbRetryInterval</span><span class="token punctuation">(</span>dbFailureRetry<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>threadsInheritInitalizersClassLoader<span class="token punctuation">)</span>
        jjs<span class="token punctuation">.</span><span class="token function">setThreadsInheritInitializersClassLoadContext</span><span class="token punctuation">(</span>threadsInheritInitalizersClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    jjs<span class="token punctuation">.</span><span class="token function">setThreadExecutor</span><span class="token punctuation">(</span>threadExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于JobStoreSupport：</p> <blockquote><p>Contains base functionality for JDBC-based JobStore implementations.</p></blockquote> <p>所以逻辑就是，如果js是数据库，那么就设置重试间隔和处理线程。</p> <p>1243行，如果是集群需要分配一个实例ID：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>js<span class="token punctuation">.</span><span class="token function">isClustered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    schedInstId <span class="token operator">=</span> instanceIdGenerator<span class="token punctuation">.</span><span class="token function">generateInstanceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实例ID有三种实现，分别是hostname，hostname+timestamp，用户配置id。</p> <p>在885行，通过用户配置的类名，用反射的方式创建Semaphore。
翻一下源码包，在org.quartz.impl.jdbcjobstore包下有SimpleSemaphore（内存）、StdRowLockSemaphore和UpdateLockRowSemaphore等。
BTW，quartz的Semaphore是自己定义的接口，没有用JDK的信号量。</p> <p>在org.quartz.impl.jdbcjobstore包下，同时也看到了一些sql文件，是用来建表的脚本。</p> <p><img src="/assets/img/2.e92e3819.png" alt=""></p> <p>867行，原来js也是反射构建的：</p> <div class="language-java extra-class"><pre class="language-java"><code>js <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JobStore</span><span class="token punctuation">)</span> loadHelper<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>jsClass<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>857行：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> jsClass <span class="token operator">=</span> cfg<span class="token punctuation">.</span><span class="token function">getStringProperty</span><span class="token punctuation">(</span>PROP_JOB_STORE_CLASS<span class="token punctuation">,</span>
        <span class="token class-name">RAMJobStore</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>到这里就解答了第一个问题，quartz是通过配置（org.quartz.jobStore.class）来区分数据库和内存。</p> <p>前面提到StdScheduler没有和QuartzSchedulerResources关联。在1321行，可以知道QuartzSchedulerResources是和QuartzScheduler关联的。</p> <h2 id="scheduler启动过程"><a href="#scheduler启动过程" class="header-anchor">#</a> Scheduler启动过程</h2> <p>QuartzScheduler的start方法是启动入口。</p> <p>schedulerStarted这个方法如果是内存，不会做任何事:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">this</span><span class="token punctuation">.</span>resources<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedulerStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>重点关注集群模式，需要先加个配置文件quartz.properties，官方的example有介绍，前文贴的quartz example里也有，这里就不贴配置了。</p> <p>重启之后，进入JobStoreSupport类的schedulerStarted()方法，这里学到了类.this的用法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">manage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ThreadExecutor</span> executor <span class="token operator">=</span> <span class="token function">getThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">ClusterManager</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述代码启动了JobStoreSupport.ClusterManager线程，该线程的关键逻辑run方法中，具体在JobStoreSupport的3957行manage()方法中：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shutdown <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">manage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">signalSchedulingChangeImmediately</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而manage()调的是doCheckin()，BTW，netty也是喜欢在关键方法上加个do。
doCheckin()的第一步就是findFailedInstances()，跟进去就会发现要先创建我们在配置文件中指定的StdJDBCDelegate，
之后，调的是StdJDBCDelegate的selectSchedulerStateRecords()，在这个方法我们总算发现了要执行的sql语句。</p> <p>所有的sql都在StdJDBCConstants类中，到这里解答了本文开始的第二个问题，quartz并没有用任何的ORM框架，而是原始的JDBC。</p> <p>最终构造出查fail instance的sql：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> qrtz_SCHEDULER_STATE <span class="token keyword">WHERE</span> SCHED_NAME <span class="token operator">=</span> <span class="token string">'TestScheduler'</span>
</code></pre></div><p>JobStoreSupport检查instance是否fail的逻辑也很简单，数据库中存了每次checkin的时间，
这个时间加上interval就是下一次该检查的时间，给个7500L的延迟，如果这样还比当前时间小，就会判定为fail：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">long</span> <span class="token function">calcFailedIfAfter</span><span class="token punctuation">(</span><span class="token class-name">SchedulerStateRecord</span> rec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> rec<span class="token punctuation">.</span><span class="token function">getCheckinTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
        <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>rec<span class="token punctuation">.</span><span class="token function">getCheckinInterval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> lastCheckin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
        <span class="token number">7500L</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>到这里就分析完了ClusterManager线程的主要逻辑，就是检查集群中各个instance是否正常，这是quartz保障高可用的核心逻辑了，也就是问题5的解答。
检测到instance失败以后，有调clusterRecover()方法，这一块后面单独分析，这里先只关注启动过程。</p> <p>如果多扣一些细节，会发现第一次Checkin时，会到qrtz_locks表里去插入两条记录(3337行commit之后才会执行插入)，作为悲观锁：</p> <p><img src="data:image/png;base64,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" alt=""></p> <p>到这里，问题4可以解答了，我们知道了悲观锁是用prepareStatement做的，具体的sql是：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> qrtz_LOCKS <span class="token keyword">WHERE</span> SCHED_NAME <span class="token operator">=</span> <span class="token string">'TestScheduler'</span> <span class="token operator">AND</span> LOCK_NAME <span class="token operator">=</span> ? <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> qrtz_LOCKS<span class="token punctuation">(</span>SCHED_NAME<span class="token punctuation">,</span> LOCK_NAME<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'TestScheduler'</span><span class="token punctuation">,</span> ?<span class="token punctuation">)</span>
</code></pre></div><p>第一个sql是行锁，第二行是执行操作（当然了这里是个特殊操作，如果已经插入过，是不会再重复插入的，对应StdRowLockSemaphore的97行的判断）。</p> <p>关于启动过程总结一下：</p> <ul><li>主要是执行jobStore的schedulerStarted()，当然有一些其他动作，但是不复杂，看看就好了。</li> <li>schedulerStarted()做两件事，一是启动ClusterManager线程，二是启动MisfireHandler线程，关于后者也专门用一小节来分析吧。</li></ul> <p>BTW，启动过程有个步骤是startPlugins()，当然我这里没有配置任何plugins，所以什么都没执行，但是这里也许会比较有趣。</p> <h2 id="节点故障的处理"><a href="#节点故障的处理" class="header-anchor">#</a> 节点故障的处理</h2> <p>在上一节，分析了ClusterManager线程负责监测集群状态，检测到检测到instance失败以后，会调clusterRecover()方法，这一节来看下源码。</p> <p>clusterRecover()在JobStoreSupport的3476行。</p> <p>对每一个fail instance，执行selectInstancesFiredTriggerRecords方法，对应的sql语句是：</p> <div class="language-java extra-class"><pre class="language-java"><code>SELECT <span class="token operator">*</span> FROM qrtz_FIRED_TRIGGERS <span class="token class-name">WHERE</span> SCHED_NAME <span class="token operator">=</span> <span class="token string">'TestScheduler'</span> <span class="token class-name">AND</span> INSTANCE_NAME <span class="token operator">=</span> instance_one
</code></pre></div><p>从数据库查到fired trigger之后，用数据表的trigger_name、trigger_group组成triggerKey，用job_name、job_group组成jobKey。</p> <p>这里稍微复杂些的是fired_triggers表中的state字段，包括triggers表中也有一个trigger_state字段。借用网上的图：</p> <p><img src="/assets/img/4.001a74f6.png" alt=""></p> <p>对每一个fired trigger：</p> <ul><li>释放BLOCKED的triggers：如果状态是BLOCKED，更新为WAITING；如果状态是PAUSED_BLOCKED，更新为PAUSED</li> <li>如果状态是ACQUIRED，更新为WAITING，否则如果fired_triggers表中的request_recovery字段为true，表示job没有执行完毕并且要求恢复</li></ul> <p>job recover的逻辑：</p> <ul><li>先用jobKey去job_details表查job是否存在。</li> <li>构造一个SimpleTriggerImpl，构造完成后插入triggers表，它的trigger_name是recover_instanceId_timestamp，标识这个trigger的特殊性，其他字段保持和原来的trigger一致。</li></ul> <p>全部遍历处理完成后，一次性删除fired_triggers表中记录。</p> <p>遍历对刚刚删除的triggers（有用HashSet保存triggerKey），查triggers表看状态是否是COMPLETE，
如果是进一步查fired_triggers表是否存在记录，没有记录时删除triggers表中的记录。</p> <p>clusterRecover()进入之前有获取STATE_ACCESS和TRIGGER_ACCESS锁的操作，执行完后commit之后就会释放锁。</p> <h2 id="quartzschedulerthread线程"><a href="#quartzschedulerthread线程" class="header-anchor">#</a> QuartzSchedulerThread线程</h2> <p>启动过程有一步是：</p> <div class="language-java extra-class"><pre class="language-java"><code>schedThread<span class="token punctuation">.</span><span class="token function">togglePause</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>schedThread这个线程是QuartzSchedulerThread类型，是调度的核心线程，定义在QuartzScheduler中。</p> <p>回顾Scheduler的创建过程，在StdSchedulerFactory的1321行：</p> <div class="language-java extra-class"><pre class="language-java"><code>qs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QuartzScheduler</span><span class="token punctuation">(</span>rsrcs<span class="token punctuation">,</span> idleWaitTime<span class="token punctuation">,</span> dbFailureRetry<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>进到QuartzScheduler的构造函数就会发现创建了QuartzSchedulerThread。</p> <p>核心逻辑在run函数：</p> <ul><li>检查halted标志，如果为true就终止</li> <li>检查paused标志，如果为true就sleep 1秒</li> <li>acquiresFailed记录了访问数据库失败的次数，如果大于1，会sleep(delay)的时间，delay如果默认是15秒</li> <li>获取可用work线程的数量（availThreadCount），如果为0，获取的过程中会阻塞直到有可用线程</li> <li>获取接下来30秒内要执行的triggers，最多获取数量maxCount由availThreadCount和配置的batchSize中的较小值决定，如果maxCount大于1需要申请TRIGGER_ACCESS锁。对于获取到的triggers，遍历，获取每个trigger对应的job，如果job标记了@ConcurrentExectionDisallowed，则跳过，否则把trigger的状态从WAITING更新为ACQUIRED。同时，也会在fired_triggers插入一条记录，状态也是ACQUIRED。</li></ul> <p>这一步比较复杂，最好debug一下，执行的sql是：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> TRIGGER_NAME<span class="token punctuation">,</span> TRIGGER_GROUP<span class="token punctuation">,</span> NEXT_FIRE_TIME<span class="token punctuation">,</span> PRIORITY <span class="token keyword">FROM</span> 

qrtz_TRIGGERS <span class="token keyword">WHERE</span> SCHED_NAME <span class="token operator">=</span> <span class="token string">'TestScheduler'</span> <span class="token operator">AND</span> TRIGGER_STATE <span class="token operator">=</span> ? 

<span class="token operator">AND</span> NEXT_FIRE_TIME <span class="token operator">&lt;=</span> ? <span class="token operator">AND</span> <span class="token punctuation">(</span>MISFIRE_INSTR <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">OR</span> <span class="token punctuation">(</span>MISFIRE_INSTR <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> 

<span class="token operator">AND</span> NEXT_FIRE_TIME <span class="token operator">&gt;=</span> ?<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> NEXT_FIRE_TIME <span class="token keyword">ASC</span><span class="token punctuation">,</span> PRIORITY <span class="token keyword">DESC</span>
</code></pre></div><p>其中的misfire有个threshold时间，默认是60秒。</p> <p>继续run方法的核心逻辑（下面部分copy自<a href="https://juejin.im/post/5c3bf24951882523d3201c54#heading-12" target="_blank" rel="noopener noreferrer">Quartz原理解密<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p> <ul><li>等待直到获取的trigger中最先执行的trigger在2ms内；</li> <li>triggersFired：
<ul><li>更新firedTrigger的status=EXECUTING;</li> <li>更新trigger下一次触发的时间；</li> <li>更新trigger的状态：无状态的trigger-&gt;WAITING，有状态的trigger-&gt;BLOCKED，若nextFireTime==null -&gt;COMPLETE；</li> <li>commit connection,释放锁；</li></ul></li> <li>针对每个要执行的trigger，创建JobRunShell，并放入线程池执行：
<ul><li>execute:执行job;</li> <li>获取TRIGGER_ACCESS锁;若是有状态的job：</li> <li>更新trigger状态：BLOCKED-&gt;WAITING,PAUSED_BLOCKED-&gt;BLOCKED;</li> <li>若@PersistJobDataAfterExecution，则updateJobData;</li> <li>删除firedTrigger;c</li> <li>ommit connection，释放锁</li></ul></li> <li>如果有查到trigger，马上进行下一次循环，如果没有则等待大概30秒，继续下一次循环</li></ul> <p>从以上过程可以看到，其实quartz没有任务分配机制，各个instance是自主一批一批的去数据库查任务，每个批次最多是可用线程数或者配置的maxBatchSize（默认是1），每一批数量都很小，这样就基本达到了集群的负载均衡。这就是问题6的解答了。</p> <h2 id="misfirehandler线程"><a href="#misfirehandler线程" class="header-anchor">#</a> MisfireHandler线程</h2> <p>对于问题3，数据结构是mysql中的那几张表，线程模型是QuartzSchedulerThread、ClusterManager、MisfireHandler、SimpleThreadPool的结合。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/14/2020, 5:58:28 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/source/jdk/Collections.sort.html" class="prev">
        Collections.sort实现原理
      </a></span> <span class="next"><a href="/design-pattern/">
        概述、原则、分类
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d45e7d8d.js" defer></script><script src="/assets/js/3.f201c9f2.js" defer></script><script src="/assets/js/2.58f2d4b3.js" defer></script><script src="/assets/js/12.5d5dd355.js" defer></script>
  </body>
</html>
