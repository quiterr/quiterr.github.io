<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《Elasticsearch权威指南》随笔 | quiterr的个人博客</title>
    <meta name="description" content="quiterr的个人博客">
    <link rel="icon" href="/assets/img/logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2fd3a0e5.css" as="style"><link rel="preload" href="/assets/js/app.d45e7d8d.js" as="script"><link rel="preload" href="/assets/js/3.f201c9f2.js" as="script"><link rel="preload" href="/assets/js/2.58f2d4b3.js" as="script"><link rel="preload" href="/assets/js/35.066a2949.js" as="script"><link rel="prefetch" href="/assets/js/10.8f6ff41b.js"><link rel="prefetch" href="/assets/js/11.d3060e6c.js"><link rel="prefetch" href="/assets/js/12.5d5dd355.js"><link rel="prefetch" href="/assets/js/13.b58b39cd.js"><link rel="prefetch" href="/assets/js/14.132da01d.js"><link rel="prefetch" href="/assets/js/15.4de3abff.js"><link rel="prefetch" href="/assets/js/16.5d01f151.js"><link rel="prefetch" href="/assets/js/17.743cc240.js"><link rel="prefetch" href="/assets/js/18.5cd47213.js"><link rel="prefetch" href="/assets/js/19.c31513f4.js"><link rel="prefetch" href="/assets/js/20.ff0c8b17.js"><link rel="prefetch" href="/assets/js/21.23bfd343.js"><link rel="prefetch" href="/assets/js/22.7b1bcdc8.js"><link rel="prefetch" href="/assets/js/23.9aa9bcc6.js"><link rel="prefetch" href="/assets/js/24.41feae7a.js"><link rel="prefetch" href="/assets/js/25.085c0a62.js"><link rel="prefetch" href="/assets/js/26.28112f5e.js"><link rel="prefetch" href="/assets/js/27.3dfa1162.js"><link rel="prefetch" href="/assets/js/28.64b59646.js"><link rel="prefetch" href="/assets/js/29.5da0daa7.js"><link rel="prefetch" href="/assets/js/30.e061c642.js"><link rel="prefetch" href="/assets/js/31.af9d5f01.js"><link rel="prefetch" href="/assets/js/32.3bb3cd16.js"><link rel="prefetch" href="/assets/js/33.28c6384b.js"><link rel="prefetch" href="/assets/js/34.e24d72db.js"><link rel="prefetch" href="/assets/js/36.3605469b.js"><link rel="prefetch" href="/assets/js/37.0f0334ec.js"><link rel="prefetch" href="/assets/js/38.c4e1f427.js"><link rel="prefetch" href="/assets/js/39.bf835b74.js"><link rel="prefetch" href="/assets/js/4.130bd99d.js"><link rel="prefetch" href="/assets/js/40.df4753ea.js"><link rel="prefetch" href="/assets/js/41.c0060482.js"><link rel="prefetch" href="/assets/js/42.13e0dffa.js"><link rel="prefetch" href="/assets/js/43.2a7ba197.js"><link rel="prefetch" href="/assets/js/44.4a50ce9b.js"><link rel="prefetch" href="/assets/js/45.04e3bb01.js"><link rel="prefetch" href="/assets/js/46.f860615e.js"><link rel="prefetch" href="/assets/js/47.57f7e152.js"><link rel="prefetch" href="/assets/js/48.c9adb86a.js"><link rel="prefetch" href="/assets/js/49.89d283b4.js"><link rel="prefetch" href="/assets/js/5.bc8341b3.js"><link rel="prefetch" href="/assets/js/50.176d29a8.js"><link rel="prefetch" href="/assets/js/51.73ee13f6.js"><link rel="prefetch" href="/assets/js/6.5dc22b3f.js"><link rel="prefetch" href="/assets/js/7.5d9116e6.js"><link rel="prefetch" href="/assets/js/8.ab4e4f3e.js"><link rel="prefetch" href="/assets/js/9.05f51b5b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2fd3a0e5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/logo.png" alt="quiterr的个人博客" class="logo"> <span class="site-name can-hide">quiterr的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://www.jianshu.com/u/e268fe04200a" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/quiterr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://www.hanclouds.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  hanclouds
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://www.jianshu.com/u/e268fe04200a" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/quiterr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://www.hanclouds.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  hanclouds
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/architecture/" class="sidebar-heading clickable"><span>架构设计</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/source/" class="sidebar-heading clickable"><span>源码阅读</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/design-pattern/" class="sidebar-heading clickable"><span>设计模式</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/frontend/" class="sidebar-heading clickable"><span>前端开发</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/database/" class="sidebar-heading clickable router-link-exact-active router-link-active open active"><span>数据库</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/database/" class="active sidebar-link">《Elasticsearch权威指南》随笔</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/#_1、基础入门" class="sidebar-link">1、基础入门</a></li><li class="sidebar-sub-header"><a href="/database/#_2、深入搜索" class="sidebar-link">2、深入搜索</a></li><li class="sidebar-sub-header"><a href="/database/#_4、聚合" class="sidebar-link">4、聚合</a></li></ul></li><li><a href="/database/mongodb.html" class="sidebar-link">MongoDB分片介绍</a></li><li><a href="/database/redis.html" class="sidebar-link">一致性hash和redis集群</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/collection/" class="sidebar-heading clickable"><span>资料收藏</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="《elasticsearch权威指南》随笔"><a href="#《elasticsearch权威指南》随笔" class="header-anchor">#</a> 《Elasticsearch权威指南》随笔</h1> <p>2019.1.20</p> <h2 id="_1、基础入门"><a href="#_1、基础入门" class="header-anchor">#</a> 1、基础入门</h2> <h3 id="_1-1-一个例子"><a href="#_1-1-一个例子" class="header-anchor">#</a> 1.1 一个例子</h3> <p><strong>插入一些测试数据（自动创建Index）</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;172.16.20.64:39200/megacorp/employee/1&quot; -H 'Content-Type: application/json' -d'
{
    &quot;first_name&quot; : &quot;John&quot;,
    &quot;last_name&quot; :  &quot;Smith&quot;,
    &quot;age&quot; :        25,
    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,
    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]
}
'
curl -X PUT &quot;172.16.20.64:39200/megacorp/employee/2&quot; -H 'Content-Type: application/json' -d'
{
    &quot;first_name&quot; :  &quot;Jane&quot;,
    &quot;last_name&quot; :   &quot;Smith&quot;,
    &quot;age&quot; :         32,
    &quot;about&quot; :       &quot;I like to collect rock albums&quot;,
    &quot;interests&quot;:  [ &quot;music&quot; ]
}
'
curl -X PUT &quot;172.16.20.64:39200/megacorp/employee/3&quot; -H 'Content-Type: application/json' -d'
{
    &quot;first_name&quot; :  &quot;Douglas&quot;,
    &quot;last_name&quot; :   &quot;Fir&quot;,
    &quot;age&quot; :         35,
    &quot;about&quot;:        &quot;I like to build cabinets&quot;,
    &quot;interests&quot;:  [ &quot;forestry&quot; ]
}
'
</code></pre></div><p><strong>查询文档</strong></p> <p><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/1&quot;</code></p> <p><strong>简单的搜索</strong></p> <p>搜全部</p> <p><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot;</code></p> <p>搜某个字段</p> <p><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search?q=last_name:Smith&quot;</code></p> <p><strong>表达式搜索</strong></p> <p>用领域特定语言（DSL）来搜索</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot; : {
        &quot;match&quot; : {
            &quot;last_name&quot; : &quot;Smith&quot;
        }
    }
}
'
</code></pre></div><p><strong>更复杂的搜索</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot; : {
        &quot;bool&quot;: {
            &quot;must&quot;: {
                &quot;match&quot; : {
                    &quot;last_name&quot; : &quot;smith&quot; 
                }
            },
            &quot;filter&quot;: {
                &quot;range&quot; : {
                    &quot;age&quot; : { &quot;gt&quot; : 30 } 
                }
            }
        }
    }
}
'
</code></pre></div><p><strong>全文搜索</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot; : {
        &quot;match&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    }
}
'
</code></pre></div><p><strong>短语搜索</strong></p> <p>精确匹配一系列单词或者短语 。 比如， 我们想执行这样一个查询，仅匹配同时包含 “rock” 和 “climbing” ，并且 二者以短语 “rock climbing” 的形式紧挨着的雇员记录。</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot; : {
        &quot;match_phrase&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    }
}
'
</code></pre></div><p><strong>高亮搜索</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot; : {
        &quot;match_phrase&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    },
    &quot;highlight&quot;: {
        &quot;fields&quot; : {
            &quot;about&quot; : {}
        }
    }
}
'
</code></pre></div><p><strong>分析</strong></p> <p>挖掘出雇员中最受欢迎的兴趣爱好：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot; -H 'Content-Type: application/json' -d'
{
  &quot;aggs&quot;: {
    &quot;all_interests&quot;: {
      &quot;terms&quot;: { &quot;field&quot;: &quot;interests&quot; }
    }
  }
}
'
</code></pre></div><p>叫 Smith 的雇员中最受欢迎的兴趣爱好</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot; -H 'Content-Type: application/json' -d'
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;last_name&quot;: &quot;smith&quot;
    }
  },
  &quot;aggs&quot;: {
    &quot;all_interests&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;interests&quot;
      }
    }
  }
}
'
</code></pre></div><p>聚合还支持分级汇总 。比如，查询特定兴趣爱好员工的平均年龄：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;172.16.20.64:39200/megacorp/employee/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;aggs&quot; : {
        &quot;all_interests&quot; : {
            &quot;terms&quot; : { &quot;field&quot; : &quot;interests&quot; },
            &quot;aggs&quot; : {
                &quot;avg_age&quot; : {
                    &quot;avg&quot; : { &quot;field&quot; : &quot;age&quot; }
                }
            }
        }
    }
}
'
</code></pre></div><h3 id="_1-2-集群原理"><a href="#_1-2-集群原理" class="header-anchor">#</a> 1.2 集群原理</h3> <p><strong>集群概述</strong></p> <p>原生支持水平扩容。</p> <p>集群有一个主节点，负责索引、节点的创建、删除，但并不到文档级别，请求可以发到任意节点，因此主节点的负载并不会比普通节点高很多。</p> <p><strong>集群健康</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/_cluster/health&quot;
</code></pre></div><p>green所有的主分片和副本分片都正常运行。
yellow所有的主分片都正常运行，但不是所有的副本分片都正常运行。
red有主分片没能正常运行。</p> <p><strong>添加索引</strong></p> <p>一个分片是一个底层的工作单元 ，它仅保存了全部数据中的一部分。一个分片是一个 Lucene 的实例，它本身就是一个完整的搜索引擎。</p> <p>Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。</p> <p>一个分片可以是 主 分片或者 副本 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。</p> <p>技术上来说，一个主分片最大能够存储 Integer.MAX_VALUE - 128 个文档，但是实际最大值还需要参考你的使用场景：包括你使用的硬件， 文档的大小和复杂程度，索引和查询文档的方式以及你期望的响应时长。</p> <p>一个副本分片只是一个主分片的拷贝。 副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p> <p>在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。</p> <p><strong>注释：查阅最新文档可知，每个索引默认有5个主分片，1个副本即5个副分片，从7.0版开始默认1个主分片</strong></p> <p><strong>添加故障转移</strong></p> <p>当第二个节点加入到集群后，3个 <em>副本分片</em> 将会分配到这个节点上。 这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。</p> <p><strong>水平扩容</strong></p> <p>Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有2个分片，而不是之前的3个。 这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片的性能将会得到提升。</p> <p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有6个分片（3个主分片和3个副本分片）的索引可以最大扩容到6个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。</p> <p>主分片的数目在索引创建时 就已经确定了下来。但是，读操作—搜索和返回数据—可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。</p> <p>动态调整集群的副本数从默认的 <code>1</code>增加到 <code>2</code></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;localhost:9200/blogs/_settings&quot; -H 'Content-Type: application/json' -d'
{
   &quot;number_of_replicas&quot; : 2
}
'
</code></pre></div><p>索引现在拥有9个分片：3个主分片和6个副本分片。 这意味着我们可以将集群扩容到9个节点，每个节点上一个分片。</p> <p><strong>应对故障</strong></p> <p>手动关掉一个节点node1，发生的第一件事就是选举新master。</p> <p>在失去node1的同时，也失去了node1上的主分片，此时集群的状态是<code>red</code>。其他节点的副本分片会提升为主分片，这个提升主分片的过程是瞬间发生的，如同按下一个开关一般，此时集群的状态将会为 <code>yellow</code> 。</p> <p>如果我们重新启动 <code>Node 1</code> ，集群可以将缺失的副本分片再次进行分配，集群的状态恢复为<code>green</code>， 如果 <code>Node 1</code> 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p> <h3 id="_1-3-数据增删查改"><a href="#_1-3-数据增删查改" class="header-anchor">#</a> 1.3 数据增删查改</h3> <p><strong>索引一个文档</strong></p> <p>PUT 表示使用这个URL存储文档，自带ID</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;localhost:9200/website/blog/123&quot; -H 'Content-Type: application/json' -d'
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;Just trying this out...&quot;,
  &quot;date&quot;:  &quot;2014/01/01&quot;
}
'
</code></pre></div><p>POST 表示存储文档在这个命名空间下，系统自动生成ID</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X POST &quot;localhost:9200/website/blog/&quot; -H 'Content-Type: application/json' -d'
{
  &quot;title&quot;: &quot;My second blog entry&quot;,
  &quot;text&quot;:  &quot;Still trying this out...&quot;,
  &quot;date&quot;:  &quot;2014/01/01&quot;
}
'
</code></pre></div><p><strong>取回一个文档</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/website/blog/123?pretty&quot;
</code></pre></div><p>显示响应的头部</p> <div class="language- extra-class"><pre class="language-text"><code>curl -i -XGET http://localhost:9200/website/blog/124?pretty
</code></pre></div><p>返回文档的一部分</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/website/blog/123?_source=title,text&quot;
</code></pre></div><p>只要source</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/website/blog/123/_source&quot;
</code></pre></div><p><strong>检查文档是否存在</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -i -XHEAD http://localhost:9200/website/blog/123
</code></pre></div><p><strong>更新整个文档</strong></p> <p>在 Elasticsearch 中文档是 <em>不可改变</em> 的，不能修改它们。如果想要更新现有的文档，需要 <em>重建索引</em>或者进行替换</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;localhost:9200/website/blog/123&quot; -H 'Content-Type: application/json' -d'
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;I am starting to get the hang of this...&quot;,
  &quot;date&quot;:  &quot;2014/01/02&quot;
}
'
</code></pre></div><p>返回结果</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;_index&quot; :   &quot;website&quot;,
  &quot;_type&quot; :    &quot;blog&quot;,
  &quot;_id&quot; :      &quot;123&quot;,
  &quot;_version&quot; : 2,
  &quot;created&quot;:   false 
}
</code></pre></div><p>_version 字段值增加了，created 标志设置成 false ，是因为相同的索引、类型和 ID 的文档已经存在。</p> <p>在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。 尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档。</p> <p><strong>创建新文档</strong></p> <p>使用PUT有可能是创建，也有可能是更新。确保创建新文档可以使用POST，但有可能相同内容的文档已存在，这样创建只是_id不同。以下是更好的方式</p> <p>方法1</p> <div class="language- extra-class"><pre class="language-text"><code>PUT /website/blog/123?op_type=create
{ ... }
</code></pre></div><p>方法2</p> <div class="language- extra-class"><pre class="language-text"><code>PUT /website/blog/123/_create
{ ... }
</code></pre></div><p>如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 201 Created 的 HTTP 响应码。</p> <p>另一方面，如果文档已经存在，Elasticsearch 将会返回 409 Conflict 响应码。</p> <p><strong>删除文档</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X DELETE &quot;localhost:9200/website/blog/123&quot;
</code></pre></div><p><strong>处理并发冲突</strong></p> <p>比较典型的是秒杀场景，读取文档，修改库存，然后更新文档，当两个请求同时读到库存（比如100），分别修改库存为99，实际库存为98，这就是并发冲突。</p> <p><em>悲观并发控制</em></p> <p>这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</p> <p><em>乐观并发控制</em></p> <p>Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</p> <p><strong>乐观并发控制</strong></p> <p>关键就是利用了_version字段。先获取文档，返回结果里有 _version字段，假设值为1。接下来我们做更新，只有现在的 _version 为 1 时，本次更新才能成功。</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;localhost:9200/website/blog/1?version=1&quot; -H 'Content-Type: application/json' -d'
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;Starting to get the hang of this...&quot;
}
'
</code></pre></div><p>当冲突发生时，该怎么做取决于应用需求。可以告诉用户说其他人已经修改了文档，并且在再次保存之前检查这些修改内容。 或者，在之前的秒杀场景，可以获取到最新的文档并尝试重新应用这些修改。</p> <p><strong>通过外部系统使用版本控制</strong></p> <p>如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp — 那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号，版本号最大是long型。</p> <p>外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 <code>_version</code> 和请求中指定的版本号是否相同， 而是检查当前 <code>_version</code> 是否 <em>小于</em> 指定的版本号。 如果请求成功，外部的版本号作为文档的新 <code>_version</code> 进行存储。</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;localhost:9200/website/blog/2?version=5&amp;version_type=external&quot; -H 'Content-Type: application/json' -d'
{
  &quot;title&quot;: &quot;My first external blog entry&quot;,
  &quot;text&quot;:  &quot;Starting to get the hang of this...&quot;
}
'
</code></pre></div><p><strong>文档的部分更新</strong></p> <p>增加字段 <code>tags</code> 和 <code>views</code> 到我们的博客文章</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X POST &quot;localhost:9200/website/blog/1/_update&quot; -H 'Content-Type: application/json' -d'
{
   &quot;doc&quot; : {
      &quot;tags&quot; : [ &quot;testing&quot; ],
      &quot;views&quot;: 0
   }
}
'
</code></pre></div><p>使用脚本更新（脚本功能默认禁用）</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X POST &quot;localhost:9200/website/blog/1/_update&quot; -H 'Content-Type: application/json' -d'
{
   &quot;script&quot; : &quot;ctx._source.views+=1&quot;
}
'
</code></pre></div><p>脚本的更多内容参见原文。</p> <p><strong>upsert操作</strong></p> <div class="language- extra-class"><pre class="language-text"><code>curl -X POST &quot;localhost:9200/website/pageviews/1/_update&quot; -H 'Content-Type: application/json' -d'
{
   &quot;script&quot; : &quot;ctx._source.views+=1&quot;,
   &quot;upsert&quot;: {
       &quot;views&quot;: 1
   }
}
'
</code></pre></div><p>第一次运行这个请求时， upsert 值作为新文档被索引，初始化 views 字段为 1 。 在后续的运行中，由于文档已经存在， script 更新操作将替代 upsert 进行应用，对 views 计数器进行累加。</p> <p><strong>更新和冲突</strong></p> <p>对于执行顺序无关的情形，只要重试就可以了</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X POST &quot;localhost:9200/website/pageviews/1/_update?retry_on_conflict=5&quot; -H 'Content-Type: application/json' -d'
{
   &quot;script&quot; : &quot;ctx._source.views+=1&quot;,
   &quot;upsert&quot;: {
       &quot;views&quot;: 0
   }
}
'
</code></pre></div><p><strong>取回多个文档</strong></p> <p><code>mget</code> API 要求有一个 <code>docs</code> 数组作为参数，每个 元素包含需要检索文档的元数据， 包括 <code>_index</code> 、 <code>_type</code>和 <code>_id</code> 。如果你想检索一个或者多个特定的字段，那么你可以通过 <code>_source</code> 参数来指定这些字段的名字：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/_mget&quot; -H 'Content-Type: application/json' -d'
{
   &quot;docs&quot; : [
      {
         &quot;_index&quot; : &quot;website&quot;,
         &quot;_type&quot; :  &quot;blog&quot;,
         &quot;_id&quot; :    2
      },
      {
         &quot;_index&quot; : &quot;website&quot;,
         &quot;_type&quot; :  &quot;pageviews&quot;,
         &quot;_id&quot; :    1,
         &quot;_source&quot;: &quot;views&quot;
      }
   ]
}
'
</code></pre></div><p>如果想检索的数据都在相同的 <code>_index</code> 中（甚至相同的 <code>_type</code> 中），则可以在 URL 中指定默认的 <code>/_index</code>或者默认的 <code>/_index/_type</code> 。你仍然可以通过单独请求覆盖这些值：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/website/blog/_mget&quot; -H 'Content-Type: application/json' -d'
{
   &quot;docs&quot; : [
      { &quot;_id&quot; : 2 },
      { &quot;_type&quot; : &quot;pageviews&quot;, &quot;_id&quot; :   1 }
   ]
}
'
</code></pre></div><p>事实上，如果所有文档的 <code>_index</code> 和 <code>_type</code> 都是相同的，你可以只传一个 <code>ids</code> 数组，而不是整个 <code>docs</code> 数组：</p> <div class="language- extra-class"><pre class="language-text"><code>GET /website/blog/_mget
{
   &quot;ids&quot; : [ &quot;2&quot;, &quot;1&quot; ]
}
</code></pre></div><p>即使有某个文档没有找到，上述请求的 HTTP 状态码仍然是 <code>200</code> 。事实上，即使请求 没有找到任何文档，它的状态码依然是 <code>200</code> --因为 <code>mget</code> 请求本身已经成功执行。 为了确定某个文档查找是成功或者失败，你需要检查 <code>found</code> 标记。</p> <p><strong>代价较小的批量操作</strong></p> <p>bulk API 允许在单个步骤中进行多次 create 、 index 、 update 或 delete 请求。</p> <p>这块比较复杂，<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/bulk.html" target="_blank" rel="noopener noreferrer">参见原文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_1-4-分布式文档存储"><a href="#_1-4-分布式文档存储" class="header-anchor">#</a> 1.4 分布式文档存储</h3> <h3 id="_1-5-搜索"><a href="#_1-5-搜索" class="header-anchor">#</a> 1.5 搜索</h3> <p>书中给的脚本执行报错</p> <div class="language- extra-class"><pre class="language-text"><code>illegal_argument_exception&quot;,&quot;reason&quot;:&quot;Failed to parse value [1] as only [true] or [false] are allowed.
</code></pre></div><p>这是因为pretty=1已经不支持了，改成pretty=true即可，或者删掉这个。</p> <p>后来又报这样一个错，原因是ES6之后每个index下只能有一个type，<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch" target="_blank" rel="noopener noreferrer">深入理解1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html" target="_blank" rel="noopener noreferrer">深入理解2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language- extra-class"><pre class="language-text"><code>final mapping would have more than 1 type error
</code></pre></div><p>对脚本做了修改，添加2个用户</p> <div class="language- extra-class"><pre class="language-text"><code>curl -XPUT 'http://localhost:9200/us/user/1' -d '
{
   &quot;email&quot; : &quot;john@smith.com&quot;,
   &quot;name&quot; : &quot;John Smith&quot;,
   &quot;username&quot; : &quot;@john&quot;
}
'

curl -XPUT 'http://localhost:9200/us/user/2' -d '
{
   &quot;email&quot; : &quot;mary@jones.com&quot;,
   &quot;name&quot; : &quot;Mary Jones&quot;,
   &quot;username&quot; : &quot;@mary&quot;
}
'
</code></pre></div><p>添加12个tweet</p> <div class="language- extra-class"><pre class="language-text"><code>curl -XPUT 'http://172.16.20.64:39200/gb/tweet/3' -d '
{
   &quot;date&quot; : &quot;2014-09-13&quot;,
   &quot;name&quot; : &quot;Mary Jones&quot;,
   &quot;tweet&quot; : &quot;Elasticsearch means full text search has never been so easy&quot;,
   &quot;user_id&quot; : 2
}
'

curl -XPUT 'http://localhost:9200/gb/tweet/4' -d '
{
   &quot;date&quot; : &quot;2014-09-14&quot;,
   &quot;name&quot; : &quot;John Smith&quot;,
   &quot;tweet&quot; : &quot;@mary it is not just text, it does everything&quot;,
   &quot;user_id&quot; : 1
}
'

curl -XPUT 'http://172.16.20.64:39200/gb/tweet/5' -d '
{
   &quot;date&quot; : &quot;2014-09-15&quot;,
   &quot;name&quot; : &quot;Mary Jones&quot;,
   &quot;tweet&quot; : &quot;However did I manage before Elasticsearch?&quot;,
   &quot;user_id&quot; : 2
}
'

curl -XPUT 'http://localhost:9200/gb/tweet/6' -d '
{
   &quot;date&quot; : &quot;2014-09-16&quot;,
   &quot;name&quot; : &quot;John Smith&quot;,
   &quot;tweet&quot; : &quot;The Elasticsearch API is really easy to use&quot;,
   &quot;user_id&quot; : 1
}
'

curl -XPUT 'http://172.16.20.64:39200/gb/tweet/7' -d '
{
   &quot;date&quot; : &quot;2014-09-17&quot;,
   &quot;name&quot; : &quot;Mary Jones&quot;,
   &quot;tweet&quot; : &quot;The Query DSL is really powerful and flexible&quot;,
   &quot;user_id&quot; : 2
}
'

curl -XPUT 'http://localhost:9200/gb/tweet/8' -d '
{
   &quot;date&quot; : &quot;2014-09-18&quot;,
   &quot;name&quot; : &quot;John Smith&quot;,
   &quot;user_id&quot; : 1
}
'

curl -XPUT 'http://172.16.20.64:39200/gb/tweet/9' -d '
{
   &quot;date&quot; : &quot;2014-09-19&quot;,
   &quot;name&quot; : &quot;Mary Jones&quot;,
   &quot;tweet&quot; : &quot;Geo-location aggregations are really cool&quot;,
   &quot;user_id&quot; : 2
}
'

curl -XPUT 'http://localhost:9200/gb/tweet/10' -d '
{
   &quot;date&quot; : &quot;2014-09-20&quot;,
   &quot;name&quot; : &quot;John Smith&quot;,
   &quot;tweet&quot; : &quot;Elasticsearch surely is one of the hottest new NoSQL products&quot;,
   &quot;user_id&quot; : 1
}
'

curl -XPUT 'http://172.16.20.64:39200/gb/tweet/11' -d '
{
   &quot;date&quot; : &quot;2014-09-21&quot;,
   &quot;name&quot; : &quot;Mary Jones&quot;,
   &quot;tweet&quot; : &quot;Elasticsearch is built for the cloud, easy to scale&quot;,
   &quot;user_id&quot; : 2
}
'

curl -XPUT 'http://localhost:9200/gb/tweet/12' -d '
{
   &quot;date&quot; : &quot;2014-09-22&quot;,
   &quot;name&quot; : &quot;John Smith&quot;,
   &quot;tweet&quot; : &quot;Elasticsearch and I have left the honeymoon stage, and I still love her.&quot;,
   &quot;user_id&quot; : 1
}
'

curl -XPUT 'http://172.16.20.64:39200/gb/tweet/13' -d '
{
   &quot;date&quot; : &quot;2014-09-23&quot;,
   &quot;name&quot; : &quot;Mary Jones&quot;,
   &quot;tweet&quot; : &quot;So yes, I am an Elasticsearch fanboy&quot;,
   &quot;user_id&quot; : 2
}
'

curl -XPUT 'http://localhost:9200/gb/tweet/14' -d '
{
   &quot;date&quot; : &quot;2014-09-24&quot;,
   &quot;name&quot; : &quot;John Smith&quot;,
   &quot;tweet&quot; : &quot;How many more cheesy tweets do I have to write?&quot;,
   &quot;user_id&quot; : 1
}
'
</code></pre></div><h4 id="_1-5-1空搜索"><a href="#_1-5-1空搜索" class="header-anchor">#</a> 1.5.1空搜索</h4> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/_search&quot;
</code></pre></div><p>这个搜索可以得到一些汇总情况。</p> <div class="language- extra-class"><pre class="language-text"><code>GET /_search?timeout=10ms
</code></pre></div><p>可以指定超时时间，如果超时，结果中的time_out为true，但结果仍会返回。</p> <h4 id="_1-5-2-多索引多类型"><a href="#_1-5-2-多索引多类型" class="header-anchor">#</a> 1.5.2 多索引多类型</h4> <p>这一节的内容应该已经失效了，至少ES6以后已经没有多类型了。但是多索引应该有参考价值。</p> <div class="language- extra-class"><pre class="language-text"><code>/gb,us/_search
</code></pre></div><p>在 <code>gb</code> 和 <code>us</code> 索引中搜索所有的文档</p> <div class="language- extra-class"><pre class="language-text"><code>/g*,u*/_search
</code></pre></div><p>在任何以 <code>g</code> 或者 <code>u</code> 开头的索引中搜索所有的类型</p> <div class="language- extra-class"><pre class="language-text"><code>/_all/tweet/_search
</code></pre></div><p>在所有的索引中搜索  <code>tweet</code> 类型</p> <h4 id="_1-5-3-分页"><a href="#_1-5-3-分页" class="header-anchor">#</a> 1.5.3 分页</h4> <p>和 SQL 使用 <code>LIMIT</code> 关键字返回单个 <code>page</code> 结果的方法相同，Elasticsearch 接受 <code>from</code> 和 <code>size</code> 参数：</p> <ul><li><p><code>size</code></p> <p>显示应该返回的结果数量，默认是 <code>10</code></p></li> <li><p><code>from</code></p> <p>显示应该跳过的初始结果数量，默认是 <code>0</code></p></li></ul> <p>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/_search?size=5&quot;
curl -X GET &quot;localhost:9200/_search?size=5&amp;from=5&quot;
curl -X GET &quot;localhost:9200/_search?size=5&amp;from=10&quot;
</code></pre></div><p>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。</p> <p><strong>深度分页的问题</strong></p> <p>理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 <em>协调节点</em> ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p> <p>现在假设我们请求第 1000 页--结果从 10001 到 10010 。每个分片不得不产生前10010个结果， 然后协调节点对全部 50050 个结果排序，最后丢弃掉这些结果中的 50040 个结果。</p> <p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。</p> <h4 id="_1-5-4-轻量搜索"><a href="#_1-5-4-轻量搜索" class="header-anchor">#</a> 1.5.4 轻量搜索</h4> <p>轻量搜索就是查询参数都在url中的搜索，相对的是“请求体搜索”，在请求body中携带更复杂的查询条件。</p> <p>查询<code>gb</code>索引在 <code>tweet</code> 类型中 <code>tweet</code> 字段包含 <code>elasticsearch</code> 单词的文档</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/gb/tweet/_search?q=tweet:elasticsearch&quot;
</code></pre></div><p>下一个查询在 <code>name</code> 字段中包含 <code>marry</code> 并且在 <code>tweet</code> 字段中包含 <code>full</code> 的文档。实际的查询就是这样</p> <div class="language- extra-class"><pre class="language-text"><code>GET /gb/tweet/_search?q=+name:mary +tweet:full
</code></pre></div><p>但是用curl时符号要转码，%2B是加号，%3A是冒号，随便找个在线URL加解码网站就可以转换</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/_search?q=%2Bname%3Amary%2Btweet%3Afull&quot;
</code></pre></div><p><code>+</code> 前缀表示必须与查询条件匹配。类似地， <code>-</code> 前缀表示一定不与查询条件匹配。没有 <code>+</code> 或者 <code>-</code> 的所有其他条件都是可选的——匹配的越多，文档就越相关。</p> <p><strong>_all字段</strong></p> <p>试试这个查询</p> <div class="language- extra-class"><pre class="language-text"><code>GET /us,gb/user,tweet/_search?q=mary
</code></pre></div><p>这个查询的结果在三个地方提到了 <code>mary</code>：</p> <ul><li>有一个用户叫做 Mary</li> <li>6条微博发自 Mary</li> <li>一条微博直接 @mary</li></ul> <p>当索引一个文档的时候，Elasticsearch 取出所有字段的值拼接成一个大的字符串，作为 _all 字段进行索引。例如，当索引这个文档时：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;tweet&quot;:    &quot;However did I manage before Elasticsearch?&quot;,
    &quot;date&quot;:     &quot;2014-09-14&quot;,
    &quot;name&quot;:     &quot;Mary Jones&quot;,
    &quot;user_id&quot;:  1
}
</code></pre></div><p>这就好似增加了一个名叫 <code>_all</code> 的额外字段：</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1&quot;
</code></pre></div><p>除非设置特定字段，否则查询字符串就使用 <code>_all</code> 字段进行搜索。</p> <p>当 _all 字段不再有用的时候，可以将它置为失效。</p> <p><strong>更复杂的查询</strong></p> <p>这个例子直接看书吧，总体来说，轻量搜索一般用在开发、测试阶段，生产上还是用请求体查询。</p> <h3 id="_1-6-映射和分析"><a href="#_1-6-映射和分析" class="header-anchor">#</a> 1.6 映射和分析</h3> <p>这一节的内容有些过时了，书中说</p> <div class="language- extra-class"><pre class="language-text"><code>GET /_search?q=2014              # 12 results
GET /_search?q=2014-09-15        # 12 results !
GET /_search?q=date:2014-09-15   # 1  result
GET /_search?q=date:2014         # 0  results !
</code></pre></div><p>但实际结果是</p> <div class="language- extra-class"><pre class="language-text"><code>GET /gb/tweet/_search?q=2014              # 0 result
GET /gb/tweet/_search?q=2014-09-15        # 1 result
GET /gb/tweet/_search?q=date:2014-09-15   # 1 result
GET /gb/tweet/_search?q=date:2014         # 0 result
</code></pre></div><p>猜测是_all没有开启，<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/root-object.html#all-field" target="_blank" rel="noopener noreferrer"> _all的配置<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>尝试开启_all，结果</p> <div class="language- extra-class"><pre class="language-text"><code>Enabling [_all] is disabled in 6.0. As a replacement, you can use [copy_to] on mapping fields to create your own catch all field.
</code></pre></div><p><strong>查看映射</strong></p> <div class="language- extra-class"><pre class="language-text"><code>GET /gb/_mapping/tweet
</code></pre></div><p>按书中的解释，date字段是date类型的，_all是string类型，索引方式不同，所以查询结果不同。</p> <p>但在ES6里，string都被表示成了text类型，用了field映射，如下是ES6的返回结果</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;gb&quot;: {
    &quot;mappings&quot;: {
      &quot;tweet&quot;: {
        &quot;properties&quot;: {
          &quot;date&quot;: {
            &quot;type&quot;: &quot;date&quot;
          },
          &quot;name&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          },
          &quot;tweet&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          },
          &quot;user_id&quot;: {
            &quot;type&quot;: &quot;long&quot;
          }
        }
      }
    }
  }
}
</code></pre></div><p><strong><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html#_field_datatypes" target="_blank" rel="noopener noreferrer">ES6的字段类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong></p> <h4 id="_1-6-1-精确值和全文"><a href="#_1-6-1-精确值和全文" class="header-anchor">#</a> 1.6.1 精确值和全文</h4> <p>Elasticsearch 中的数据可以概括的分为两类：精确值和全文。</p> <p>精确值 如它们听起来那样精确。例如日期或者用户 ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，Foo 和 foo 是不同的，2014 和 2014-09-15 也是不同的。</p> <p>另一方面，全文 是指文本数据（通常以人类容易识别的语言书写），例如一个推文的内容或一封邮件的内容。</p> <p>精确值很容易查询。结果是二进制的：要么匹配查询，要么不匹配。这种查询很容易用 SQL 表示：</p> <div class="language- extra-class"><pre class="language-text"><code>WHERE name    = &quot;John Smith&quot;
  AND user_id = 2
  AND date    &gt; &quot;2014-09-15&quot;
</code></pre></div><p>查询全文数据要微妙的多。我们问的不只是“这个文档匹配查询吗”，而是“该文档匹配查询的程度有多大？”换句话说，该文档与给定查询的相关性如何？</p> <p>查询全文数据要微妙的多。我们问的不只是“这个文档匹配查询吗”，而是“该文档匹配查询的程度有多大？”换句话说，该文档与给定查询的相关性如何？</p> <p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的 <em>意图</em> ：</p> <ul><li>搜索 <code>UK</code> ，会返回包含 <code>United Kindom</code> 的文档。</li> <li>搜索 <code>jump</code> ，会匹配 <code>jumped</code> ， <code>jumps</code> ， <code>jumping</code> ，甚至是 <code>leap</code> 。</li> <li>搜索 <code>johnny walker</code> 会匹配 <code>Johnnie Walker</code> ， <code>johnnie depp</code> 应该匹配 <code>Johnny Depp</code> 。</li> <li><code>fox news hunting</code> 应该返回福克斯新闻（ Foxs News ）中关于狩猎的故事，同时， <code>fox hunting news</code> 应该返回关于猎狐的故事。</li></ul> <p>为了促进这类在全文域中的查询，Elasticsearch 首先 <em>分析</em> 文档，之后根据结果创建 <em>倒排索引</em> 。在接下来的两节，我们会讨论倒排索引和分析过程。</p> <h4 id="_1-6-2-倒排索引"><a href="#_1-6-2-倒排索引" class="header-anchor">#</a> 1.6.2 倒排索引</h4> <p>倒排索引之前我在别的地方学过了，不再重复记录，详见书中原文。</p> <h4 id="_1-6-3-分析和分析器"><a href="#_1-6-3-分析和分析器" class="header-anchor">#</a> 1.6.3 分析和分析器</h4> <p>分词和标准化的过程称为 <em>分析</em>（如果对这句话不理解，请看书中上一小节“倒排索引”）。</p> <p>分析的过程</p> <ul><li>首先，将一块文本分成适合于倒排索引的独立的 <em>词条</em> ，</li> <li>之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者叫 <em>recall</em></li></ul> <p>分析实际上有三个功能</p> <ul><li>字符过滤器：负责在分词前整理字符串，比如去掉HTML或把&amp;转换为and</li> <li>分词器：比如按空格或逗号分词</li> <li>Token过滤器：改变词条（如Quick变quick）、删除词条（如‘and’、‘a’、‘the’等无用词）、或者增加词条（如像 <code>jump</code> 和 <code>leap</code> 这种同义词）</li></ul> <p>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。</p> <p><strong>内置的分析器</strong></p> <p>为了分辨不同分析器的差别，给一个例子字符串</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;
</code></pre></div><p>标准分析器（默认）</p> <p>它根据 <a href="http://www.unicode.org/reports/tr29/" target="_blank" rel="noopener noreferrer">Unicode 联盟<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 定义的 <em>单词边界</em> 划分文本。删除绝大部分标点。最后，将词条小写。它会产生</p> <div class="language- extra-class"><pre class="language-text"><code>set, the, shape, to, semi, transparent, by, calling, set_trans, 5
</code></pre></div><p>简单分析器</p> <p>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生</p> <div class="language- extra-class"><pre class="language-text"><code>set, the, shape, to, semi, transparent, by, calling, set, trans
</code></pre></div><p>语言分析器</p> <p>特定语言分析器可用于 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html" target="_blank" rel="noopener noreferrer">很多语言<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。它们可以考虑指定语言的特点。例如， <code>英语</code> 分析器附带了一组英语无用词（常用单词，例如 <code>and</code> 或者 <code>the</code> ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 <em>词干</em> 。</p> <p><code>英语</code> 分词器会产生下面的词条：</p> <div class="language- extra-class"><pre class="language-text"><code>set, shape, semi, transpar, call, set_tran, 5
</code></pre></div><p>注意看 <code>transparent</code>、 <code>calling</code> 和 <code>set_trans</code> 已经变为词根格式。</p> <p><strong>分析器的应用</strong></p> <p>当我们 <em>索引</em> 一个文档，它的全文域被分析成词条以用来创建倒排索引。搜索的时候也要经过相同的分析过程，这样保证搜索的词条和索引中的词条一致。</p> <ul><li>当你查询一个 <em>全文</em> 字段时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。</li> <li>当你查询一个 <em>精确值</em> 字段时，不会分析查询字符串， 而是搜索你指定的精确值。</li></ul> <p>现在可以来解释本节开始的搜索结果了。</p> <ul><li><code>date</code> 字段包含一个精确值：单独的词条 <code>2014-09-15</code>。</li> <li><code>_all</code> 字段是一个全文域，所以分词进程将日期转化为三个词条： <code>2014</code>， <code>09</code>， 和 <code>15</code>。</li></ul> <p><strong>测试分析器</strong></p> <p>使用 <code>analyze</code> API 来看文本是如何被分析的</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/_analyze&quot; -H 'Content-Type: application/json' -d'
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;Text to analyze&quot;
}
'
</code></pre></div><p><strong>指定分析器</strong></p> <p>当Elasticsearch在你的文档中检测到一个新的字符串字段 ，它会自动设置其为一个全文 <code>字符串</code> 字段，使用 <code>标准</code> 分析器对它进行分析。</p> <p>可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域--不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。下一节的映射就是用来干这个的。</p> <h4 id="_1-6-4-映射"><a href="#_1-6-4-映射" class="header-anchor">#</a> 1.6.4 映射</h4> <p>为了能够将时间域视为时间，数字域视为数字，字符串字段视为全文或精确值字符串， Elasticsearch 需要知道每个字段中数据的类型。这个信息包含在映射中。本节是映射的入门内容，后边还会详述。</p> <p>本小节的内容有些过时了 直接看最新文档更好 <strong><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html#_field_datatypes" target="_blank" rel="noopener noreferrer">ES6的字段类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong>。在最新的ES中，string类型被拆成了text（全文字段）和keyword（精确字段）。</p> <p><strong>查看映射</strong></p> <p>1.6节开始就讲了如何查看映射。</p> <div class="language- extra-class"><pre class="language-text"><code>GET /gb/_mapping/tweet
</code></pre></div><p>如果想要自己创建映射，需要先创建空索引</p> <div class="language- extra-class"><pre class="language-text"><code>PUT cars 
{}
</code></pre></div><p><strong>更新映射</strong></p> <p>可以为索引增加映射，但不能修改已存在字段的映射。如果一个字段的映射已经存在，那么该字段的数据可能已经被索引。如果你意图修改这个字段的映射，索引的数据可能会出错，不能被正常的搜索。</p> <p>一个添加字段映射的例子</p> <div class="language- extra-class"><pre class="language-text"><code>PUT /postcodes_test/_mapping/address
{
  &quot;properties&quot;: {
    &quot;abcd&quot;: {
      &quot;type&quot;: &quot;keyword&quot;
    }
  }
}
</code></pre></div><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html" target="_blank" rel="noopener noreferrer">更新映射官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="_1-6-5-复杂核心类型"><a href="#_1-6-5-复杂核心类型" class="header-anchor">#</a> 1.6.5 复杂核心类型</h4> <p>指的是JSON中的<code>null</code> 值，数组，和对象。</p> <p>数组中所有的值必须是相同数据类型。不能对数组内部进行排序。</p> <p><strong>空类型</strong></p> <p>下面三种值被认为是空的，它们将不会被索引：</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;null_value&quot;:               null,
&quot;empty_array&quot;:              [],
&quot;array_with_null_value&quot;:    [ null ]
</code></pre></div><p><strong>多层级对象</strong></p> <p>例如，与其在 <code>tweet</code> 文档中包含 <code>user_name</code> 和 <code>user_id</code> 域，我们也可以这样写：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;tweet&quot;:            &quot;Elasticsearch is very flexible&quot;,
    &quot;user&quot;: {
        &quot;id&quot;:           &quot;@johnsmith&quot;,
        &quot;gender&quot;:       &quot;male&quot;,
        &quot;age&quot;:          26,
        &quot;name&quot;: {
            &quot;full&quot;:     &quot;John Smith&quot;,
            &quot;first&quot;:    &quot;John&quot;,
            &quot;last&quot;:     &quot;Smith&quot;
        }
    }
}
</code></pre></div><p><strong>内部对象的映射</strong></p> <p>Elasticsearch 会动态监测新的对象字段并映射它们为<code>对象</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;gb&quot;: {
    &quot;tweet&quot;: { 
      &quot;properties&quot;: {
        &quot;tweet&quot;: { &quot;type&quot;: &quot;string&quot; },
        &quot;user&quot;: { 
          &quot;type&quot;: &quot;object&quot;,
          &quot;properties&quot;: {
            &quot;id&quot;: { &quot;type&quot;: &quot;string&quot; },
            &quot;gender&quot;: { &quot;type&quot;: &quot;string&quot; },
            &quot;age&quot;: { &quot;type&quot;: &quot;long&quot; },
            &quot;name&quot;:   { 
              &quot;type&quot;:  &quot;object&quot;,
              &quot;properties&quot;: {
                &quot;full&quot;: { &quot;type&quot;: &quot;string&quot; },
                &quot;first&quot;: { &quot;type&quot;: &quot;string&quot; },
                &quot;last&quot;: { &quot;type&quot;: &quot;string&quot; }
              }
            }
          }
        }
      }
    }
  }
}
</code></pre></div><p><code>user</code> 和 <code>name</code> 域的映射结构与 <code>tweet</code> 类型的相同。事实上， <code>type</code> 映射只是一种特殊的 <code>对象</code> 映射，我们称之为 <em>根对象</em> 。除了它有一些文档元数据的特殊顶级域，例如 <code>_source</code> 和 <code>_all</code> 域，它和其他对象一样。</p> <p><strong>内部对象是如何被索引的</strong></p> <p>Lucene 不理解内部对象。 Lucene 文档是由一组键值对列表组成的。为了能让 Elasticsearch 有效地索引内部类，它把我们的文档转化成这样：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;tweet&quot;:            [elasticsearch, flexible, very],
    &quot;user.id&quot;:          [@johnsmith],
    &quot;user.gender&quot;:      [male],
    &quot;user.age&quot;:         [26],
    &quot;user.name.full&quot;:   [john, smith],
    &quot;user.name.first&quot;:  [john],
    &quot;user.name.last&quot;:   [smith]
}
</code></pre></div><p>在这个简单扁平的文档中，没有 <code>user</code> 和 <code>user.name</code> 域。Lucene 索引只有标量和简单值，没有复杂数据结构。</p> <p><strong>内部对象数组</strong></p> <p>假设我们有个 <code>followers</code> 数组：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;followers&quot;: [
        { &quot;age&quot;: 35, &quot;name&quot;: &quot;Mary White&quot;},
        { &quot;age&quot;: 26, &quot;name&quot;: &quot;Alex Jones&quot;},
        { &quot;age&quot;: 19, &quot;name&quot;: &quot;Lisa Smith&quot;}
    ]
}
</code></pre></div><p>这个文档会像我们之前描述的那样被扁平化处理，结果如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;followers.age&quot;:    [19, 26, 35],
    &quot;followers.name&quot;:   [alex, jones, lisa, smith, mary, white]
}
</code></pre></div><p><code>{age: 35}</code> 和 <code>{name: Mary White}</code> 之间的相关性已经丢失了，不能回答这样的问题：“是否有一个26岁 <em>名字叫 Alex Jones</em> 的followers？”</p> <p>ES提供了一种<em>nested</em> 对象来解决该问题。</p> <h3 id="_1-7-请求体查询"><a href="#_1-7-请求体查询" class="header-anchor">#</a> 1.7 请求体查询</h3> <h4 id="_1-7-1-空查询"><a href="#_1-7-1-空查询" class="header-anchor">#</a> 1.7.1 空查询</h4> <div class="language- extra-class"><pre class="language-text"><code>curl -XGET &quot;http://172.16.20.64:39200/my_index/_search&quot; -H 'Content-Type: application/json' -d'
{}'
</code></pre></div><p>使用 <code>from</code> 和 <code>size</code> 参数来分页：</p> <div class="language- extra-class"><pre class="language-text"><code>GET /my_index/_search
{
  &quot;from&quot;: 1,
  &quot;size&quot;: 10
}
</code></pre></div><blockquote><p><strong>一个带请求体的 GET 请求？</strong></p> <p>某些特定语言（特别是 JavaScript）的 HTTP 库是不允许 <code>GET</code> 请求带有请求体的。 事实上，一些使用者对于 <code>GET</code> 请求可以带请求体感到非常的吃惊。</p> <p>而事实是这个RFC文档 <a href="http://tools.ietf.org/html/rfc7231#page-24" target="_blank" rel="noopener noreferrer">RFC 7231<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>— 一个专门负责处理 HTTP 语义和内容的文档 — 并没有规定一个带有请求体的 <code>GET</code> 请求应该如何处理！结果是，一些 HTTP 服务器允许这样子，而有一些 — 特别是一些用于缓存和代理的服务器 — 则不允许。</p> <p>对于一个查询请求，Elasticsearch 的工程师偏向于使用 <code>GET</code> 方式，因为他们觉得它比 <code>POST</code> 能更好的描述信息检索（retrieving information）的行为。然而，因为带请求体的 <code>GET</code> 请求并不被广泛支持，所以 <code>search</code> API 同时支持 <code>POST</code> 请求：</p> <div class="language- extra-class"><pre class="language-text"><code>POST /_search
{
  &quot;from&quot;: 30,
  &quot;size&quot;: 10
}
</code></pre></div><p>类似的规则可以应用于任何需要带请求体的 <code>GET</code> API。</p></blockquote> <h4 id="_1-7-2-查询表达式"><a href="#_1-7-2-查询表达式" class="header-anchor">#</a> 1.7.2 查询表达式</h4> <p>查询表达式</p> <div class="language- extra-class"><pre class="language-text"><code>GET /_search
{
    &quot;query&quot;: YOUR_QUERY_HERE
}
</code></pre></div><p><em>空查询（empty search）</em> —<code>{}</code>— 在功能上等价于使用 <code>match_all</code> 查询， 正如其名字一样，匹配所有文档：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot;: {
        &quot;match_all&quot;: {}
    }
}
'
</code></pre></div><p><strong>查询语句的结构</strong></p> <p>一个查询语句 的典型结构：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    QUERY_NAME: {
        ARGUMENT: VALUE,
        ARGUMENT: VALUE,...
    }
}
</code></pre></div><p>如果是针对某个字段，那么它的结构如下：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    QUERY_NAME: {
        FIELD_NAME: {
            ARGUMENT: VALUE,
            ARGUMENT: VALUE,...
        }
    }
}
</code></pre></div><p>举个例子，你可以使用 <code>match</code> 查询语句 来查询 <code>tweet</code> 字段中包含 <code>elasticsearch</code> 的 tweet：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;match&quot;: {
        &quot;tweet&quot;: &quot;elasticsearch&quot;
    }
}
</code></pre></div><p>完整的查询请求如下：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;tweet&quot;: &quot;elasticsearch&quot;
        }
    }
}
'
</code></pre></div><p><strong>合并查询语句</strong></p> <p><em>查询语句(Query clauses)</em> 就像一些简单的组合块 ，这些组合块可以彼此之间合并组成更复杂的查询。这些语句可以是如下形式：</p> <ul><li><em>叶子语句（Leaf clauses）</em> (就像 <code>match</code> 语句) 被用于将查询字符串和一个字段（或者多个字段）对比。</li> <li><em>复合(Compound)</em> 语句 主要用于 合并其它查询语句。 比如，一个 <code>bool</code> 语句 允许在你需要的时候组合其它语句，无论是 <code>must</code> 匹配、 <code>must_not</code> 匹配还是 <code>should</code> 匹配，同时它可以包含不评分的过滤器（filters）：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;bool&quot;: {
        &quot;must&quot;:     { &quot;match&quot;: { &quot;tweet&quot;: &quot;elasticsearch&quot; }},
        &quot;must_not&quot;: { &quot;match&quot;: { &quot;name&quot;:  &quot;mary&quot; }},
        &quot;should&quot;:   { &quot;match&quot;: { &quot;tweet&quot;: &quot;full text&quot; }},
        &quot;filter&quot;:   { &quot;range&quot;: { &quot;age&quot; : { &quot;gt&quot; : 30 }} }
    }
}
</code></pre></div><p>一条复合语句可以合并任何其它查询语句，包括复合语句，了解这一点是很重要的。这就意味着，复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。</p> <p>例如，以下查询是为了找出信件正文包含 business opportunity 的星标邮件，或者在收件箱正文包含 business opportunity 的非垃圾邮件：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;bool&quot;: {
        &quot;must&quot;: { &quot;match&quot;:   { &quot;email&quot;: &quot;business opportunity&quot; }},
        &quot;should&quot;: [
            { &quot;match&quot;:       { &quot;starred&quot;: true }},
            { &quot;bool&quot;: {
                &quot;must&quot;:      { &quot;match&quot;: { &quot;folder&quot;: &quot;inbox&quot; }},
                &quot;must_not&quot;:  { &quot;match&quot;: { &quot;spam&quot;: true }}
            }}
        ],
        &quot;minimum_should_match&quot;: 1
    }
}
</code></pre></div><p>到目前为止，你不必太在意这个例子的细节，我们会在后面详细解释。最重要的是你要理解到，一条复合语句可以将多条语句 — 叶子语句和其它复合语句 — 合并成一个单一的查询语句。</p> <h4 id="_1-7-3-查询和过滤"><a href="#_1-7-3-查询和过滤" class="header-anchor">#</a> 1.7.3 查询和过滤</h4> <p>这部分啰里啰嗦，没啥好记录的。</p> <h4 id="_1-7-4-常用查询"><a href="#_1-7-4-常用查询" class="header-anchor">#</a> 1.7.4 常用查询</h4> <p><strong>match查询</strong></p> <p>无论你在任何字段上进行的是全文搜索还是精确查询，<code>match</code> 查询是你可用的标准查询。</p> <p>如果你在一个全文字段上使用 <code>match</code> 查询，在执行查询前，它将用正确的分析器去分析查询字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>{ &quot;match&quot;: { &quot;tweet&quot;: &quot;About Search&quot; }}
</code></pre></div><p>如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 <code>keyword</code> 字符串字段，那么它将会精确匹配给定的值：</p> <div class="language- extra-class"><pre class="language-text"><code>{ &quot;match&quot;: { &quot;age&quot;:    26           }}
{ &quot;match&quot;: { &quot;date&quot;:   &quot;2014-09-01&quot; }}
{ &quot;match&quot;: { &quot;public&quot;: true         }}
{ &quot;match&quot;: { &quot;tag&quot;:    &quot;full_text&quot;  }}
</code></pre></div><p>不像我们在<em>轻量</em> 搜索章节介绍的字符串查询（query-string search）， <code>match</code> 查询不使用类似 <code>+user_id:2 +tweet:search</code> 的查询语法。这就意味着将查询字段暴露给你的用户是安全的.</p> <p><strong>multi_match 查询</strong></p> <p><code>multi_match</code> 查询可以在多个字段上执行相同的 <code>match</code> 查询，例如在<code>title</code>字段和<code>body</code>字段上查询：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;multi_match&quot;: {
        &quot;query&quot;:    &quot;full text search&quot;,
        &quot;fields&quot;:   [ &quot;title&quot;, &quot;body&quot; ]
    }
}
</code></pre></div><p><strong>range查询</strong></p> <p><code>range</code> 查询找出那些落在指定区间内的数字或者时间：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;range&quot;: {
        &quot;age&quot;: {
            &quot;gte&quot;:  20,
            &quot;lt&quot;:   30
        }
    }
}
</code></pre></div><p><strong>term查询</strong></p> <p><code>term</code> 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 keyword类型的字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>{ &quot;term&quot;: { &quot;age&quot;:    26           }}
{ &quot;term&quot;: { &quot;date&quot;:   &quot;2014-09-01&quot; }}
{ &quot;term&quot;: { &quot;public&quot;: true         }}
{ &quot;term&quot;: { &quot;tag&quot;:    &quot;full_text&quot;  }}
</code></pre></div><p><code>term</code> 查询对于输入的文本不 <em>分析</em> ，所以它将给定的值进行精确查询。</p> <p><strong>terms查询</strong></p> <p><code>terms</code> 查询和 <code>term</code> 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：</p> <div class="language- extra-class"><pre class="language-text"><code>{ &quot;terms&quot;: { &quot;tag&quot;: [ &quot;search&quot;, &quot;full_text&quot;, &quot;nosql&quot; ] }}
</code></pre></div><p><strong>exists查询和missing查询</strong></p> <p><code>exists</code> 查询和 <code>missing</code> 查询被用于查找那些指定字段中有值 (<code>exists</code>) 或无值 (<code>missing</code>) 的文档。这与SQL中的 <code>IS_NULL</code> (<code>missing</code>) 和 <code>NOT IS_NULL</code> (<code>exists</code>) 在本质上具有共性：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;exists&quot;:   {
        &quot;field&quot;:    &quot;title&quot;
    }
}
</code></pre></div><h4 id="_1-7-5-组合多查询"><a href="#_1-7-5-组合多查询" class="header-anchor">#</a> 1.7.5 组合多查询</h4> <p>可以用 <code>bool</code> 查询来实现将多查询组合在一起。它接收以下参数：</p> <ul><li><p><code>must</code></p> <p>文档 <em>必须</em> 匹配这些条件才能被包含进来。</p></li> <li><p><code>must_not</code></p> <p>文档 <em>必须不</em> 匹配这些条件才能被包含进来。</p></li> <li><p><code>should</code></p> <p>如果满足这些语句中的任意语句，将增加 <code>_score</code> ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。</p></li> <li><p><code>filter</code></p> <p><em>必须</em> 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</p></li></ul> <p>由于这是我们看到的第一个包含多个查询的查询，所以有必要讨论一下相关性得分是如何组合的。每一个子查询都独自地计算文档的相关性得分。一旦他们的得分被计算出来， <code>bool</code> 查询就将这些得分进行合并并且返回一个代表整个布尔操作的得分。</p> <p>下面的查询用于查找 <code>title</code> 字段匹配 <code>how to make millions</code> 并且不被标识为 <code>spam</code> 的文档。那些被标识为 <code>starred</code> 或在2014之后的文档，将比另外那些文档拥有更高的排名。如果 <em>两者</em> 都满足，那么它排名将更高：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;bool&quot;: {
        &quot;must&quot;:     { &quot;match&quot;: { &quot;title&quot;: &quot;how to make millions&quot; }},
        &quot;must_not&quot;: { &quot;match&quot;: { &quot;tag&quot;:   &quot;spam&quot; }},
        &quot;should&quot;: [
            { &quot;match&quot;: { &quot;tag&quot;: &quot;starred&quot; }},
            { &quot;range&quot;: { &quot;date&quot;: { &quot;gte&quot;: &quot;2014-01-01&quot; }}}
        ]
    }
}
</code></pre></div><p><em>如果没有 <code>must</code> 语句，那么至少需要能够匹配其中的一条 <code>should</code> 语句。但，如果存在至少一条 <code>must</code> 语句，则对 <code>should</code> 语句的匹配没有要求。</em></p> <p><strong>带过滤器的查询</strong></p> <p>如果我们不想因为文档的时间而影响得分，可以用 <code>filter</code> 语句来重写前面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;bool&quot;: {
        &quot;must&quot;:     { &quot;match&quot;: { &quot;title&quot;: &quot;how to make millions&quot; }},
        &quot;must_not&quot;: { &quot;match&quot;: { &quot;tag&quot;:   &quot;spam&quot; }},
        &quot;should&quot;: [
            { &quot;match&quot;: { &quot;tag&quot;: &quot;starred&quot; }}
        ],
        &quot;filter&quot;: {
          &quot;range&quot;: { &quot;date&quot;: { &quot;gte&quot;: &quot;2014-01-01&quot; }} 
        }
    }
}
</code></pre></div><p>如果你需要通过多个不同的标准来过滤你的文档，<code>bool</code> 查询本身也可以被用做不评分的查询。简单地将它放置到 <code>filter</code> 语句中并在内部构建布尔逻辑：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;bool&quot;: {
        &quot;must&quot;:     { &quot;match&quot;: { &quot;title&quot;: &quot;how to make millions&quot; }},
        &quot;must_not&quot;: { &quot;match&quot;: { &quot;tag&quot;:   &quot;spam&quot; }},
        &quot;should&quot;: [
            { &quot;match&quot;: { &quot;tag&quot;: &quot;starred&quot; }}
        ],
        &quot;filter&quot;: {
          &quot;bool&quot;: { 
              &quot;must&quot;: [
                  { &quot;range&quot;: { &quot;date&quot;: { &quot;gte&quot;: &quot;2014-01-01&quot; }}},
                  { &quot;range&quot;: { &quot;price&quot;: { &quot;lte&quot;: 29.99 }}}
              ],
              &quot;must_not&quot;: [
                  { &quot;term&quot;: { &quot;category&quot;: &quot;ebooks&quot; }}
              ]
          }
        }
    }
}
</code></pre></div><p><strong>constant_score 查询</strong></p> <p><code>constant_score</code> 查询将一个不变的常量评分应用于所有匹配的文档。它被经常用于你只需要执行一个 filter 而没有其它查询（例如，评分查询）的情况下。</p> <p>可以使用它来取代只有 filter 语句的 <code>bool</code> 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;constant_score&quot;:   {
        &quot;filter&quot;: {
            &quot;term&quot;: { &quot;category&quot;: &quot;ebooks&quot; } 
        }
    }
}
</code></pre></div><p><strong>验证查询</strong></p> <p>查询可以变得非常的复杂，尤其 和不同的分析器与不同的字段映射结合时，理解起来就有点困难了。不过 <code>validate-query</code> API 可以用来验证查询是否合法。</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/gb/tweet/_validate/query&quot; -H 'Content-Type: application/json' -d'
{
   &quot;query&quot;: {
      &quot;tweet&quot; : {
         &quot;match&quot; : &quot;really powerful&quot;
      }
   }
}
'
</code></pre></div><p>以上 <code>validate</code> 请求的应答告诉我们这个查询是不合法的：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;valid&quot; :         false,
  &quot;_shards&quot; : {
    &quot;total&quot; :       1,
    &quot;successful&quot; :  1,
    &quot;failed&quot; :      0
  }
}
</code></pre></div><p><strong>理解错误信息</strong></p> <p>为了找出查询不合法的原因，可以将 <code>explain</code> 参数 加到查询字符串中：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/gb/tweet/_validate/query?explain&quot; -H 'Content-Type: application/json' -d'
{
   &quot;query&quot;: {
      &quot;tweet&quot; : {
         &quot;match&quot; : &quot;really powerful&quot;
      }
   }
}
'
</code></pre></div><p>返回了错误详情</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;valid&quot;: false,
  &quot;error&quot;: &quot;org.elasticsearch.common.ParsingException: no [query] registered for [tweet]&quot;
}
</code></pre></div><p><strong>理解查询语句</strong></p> <p>对于合法查询，使用 <code>explain</code> 参数将返回可读的描述，这对准确理解 Elasticsearch 是如何解析你的 query 是非常有用的：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -XGET &quot;http://172.16.20.64:39200/_validate/query?explain&quot; -H 'Content-Type: application/json' -d'
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;tweet&quot;: &quot;really powerful&quot;
    }
  }
}'
</code></pre></div><p>返回结果</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;_shards&quot;: {
    &quot;total&quot;: 1,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;valid&quot;: true,
  &quot;explanations&quot;: [
    {
      &quot;index&quot;: &quot;gb&quot;,
      &quot;valid&quot;: true,
      &quot;explanation&quot;: &quot;+(tweet:really tweet:powerful) #*:*&quot;
    }
  ]
}
</code></pre></div><h2 id="_2、深入搜索"><a href="#_2、深入搜索" class="header-anchor">#</a> 2、深入搜索</h2> <h3 id="_2-1-结构化搜索"><a href="#_2-1-结构化搜索" class="header-anchor">#</a> 2.1 结构化搜索</h3> <h4 id="_2-1-2-组合过滤器"><a href="#_2-1-2-组合过滤器" class="header-anchor">#</a> 2.1.2 组合过滤器</h4> <p>书中的代码</p> <div class="language- extra-class"><pre class="language-text"><code>GET /my_store/products/_search
{
   &quot;query&quot; : {
      &quot;filtered&quot; : { 
         &quot;filter&quot; : {
            &quot;bool&quot; : {
              &quot;should&quot; : [
                 { &quot;term&quot; : {&quot;price&quot; : 20}}, 
                 { &quot;term&quot; : {&quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot;}} 
              ],
              &quot;must_not&quot; : {
                 &quot;term&quot; : {&quot;price&quot; : 30} 
              }
           }
         }
      }
   }
}
</code></pre></div><p>执行起来应该会报错，因为官网已经没有filtered了，官网的代码</p> <div class="language- extra-class"><pre class="language-text"><code>GET /_search
{
  &quot;query&quot;: { 
    &quot;bool&quot;: { 
      &quot;must&quot;: [
        { &quot;match&quot;: { &quot;title&quot;:   &quot;Search&quot;        }}, 
        { &quot;match&quot;: { &quot;content&quot;: &quot;Elasticsearch&quot; }}  
      ],
      &quot;filter&quot;: [ 
        { &quot;term&quot;:  { &quot;status&quot;: &quot;published&quot; }}, 
        { &quot;range&quot;: { &quot;publish_date&quot;: { &quot;gte&quot;: &quot;2015-01-01&quot; }}} 
      ]
    }
  }
}
</code></pre></div><p><strong>filter的上一层是bool，不是filtered</strong></p> <h3 id="_2-5-部分匹配"><a href="#_2-5-部分匹配" class="header-anchor">#</a> 2.5 部分匹配</h3> <h4 id="_2-5-1-邮编和结构化数据"><a href="#_2-5-1-邮编和结构化数据" class="header-anchor">#</a> 2.5.1 邮编和结构化数据</h4> <p>我们会使用美国目前使用的邮编形式（United Kingdom postcodes 标准）来说明如何用部分匹配查询结构化数据。 这种邮编形式有很好的结构定义。例如，邮编 <code>W1V 3DG</code> 可以分解成如下形式：</p> <ul><li><code>W1V</code> ：这是邮编的外部，它定义了邮件的区域和行政区：
<ul><li><code>W</code> 代表区域（ 1 或 2 个字母）</li> <li><code>1V</code> 代表行政区（ 1 或 2 个数字，可能跟着一个字符）</li></ul></li> <li><code>3DG</code> ：内部定义了街道或建筑：
<ul><li><code>3</code> 代表街区区块（ 1 个数字）</li> <li><code>DG</code> 代表单元（ 2 个字母）</li></ul></li></ul> <p>假设将邮编作为精确值字段索引，所以可以为其创建索引，如下（脚本与书中略有不同，针对当前ES版本做了修改，拓展阅读<a href="https://blog.csdn.net/u010825931/article/details/80916399" target="_blank" rel="noopener noreferrer">Elasticsearch 6.x 和 5.x 字符串类型的差别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p> <div class="language- extra-class"><pre class="language-text"><code>PUT /postcodes_test
{
    &quot;mappings&quot;: {
        &quot;address&quot;: {
            &quot;properties&quot;: {
                &quot;postcode&quot;: {
                    &quot;type&quot;:  &quot;keyword&quot;
                }
            }
        }
    }
}
</code></pre></div><p>然后索引一些邮编作为测试数据：</p> <div class="language- extra-class"><pre class="language-text"><code>PUT /postcodes_test/address/1
{ &quot;postcode&quot;: &quot;W1V 3DG&quot; }

PUT /postcodes_test/address/2
{ &quot;postcode&quot;: &quot;W2F 8HW&quot; }

PUT /postcodes_test/address/3
{ &quot;postcode&quot;: &quot;W1F 7HW&quot; }

PUT /postcodes_test/address/4
{ &quot;postcode&quot;: &quot;WC1N 1LZ&quot; }

PUT /postcodes_test/address/5
{ &quot;postcode&quot;: &quot;SW5 0BE&quot; }
</code></pre></div><h4 id="_2-5-2-prefix前缀查询"><a href="#_2-5-2-prefix前缀查询" class="header-anchor">#</a> 2.5.2 prefix前缀查询</h4> <p>为了找到所有以 <code>W1</code> 开始的邮编，可以使用简单的 <code>prefix</code> 查询：</p> <div class="language- extra-class"><pre class="language-text"><code>GET /postcodes_test/address/_search
{
    &quot;query&quot;: {
        &quot;prefix&quot;: {
            &quot;postcode&quot;: &quot;W1&quot;
        }
    }
}
</code></pre></div><p><code>prefix</code> 查询是一个词级别的底层的查询，它不会在搜索之前分析查询字符串，它假定传入前缀就正是要查找的前缀。</p> <p>如果倒排索引中有数以百万的邮编都是以 <code>W1</code> 开头时，前缀查询则需要访问每个词然后计算结果！</p> <p>前缀越短所需访问的词越多。如果我们要以 <code>W</code> 作为前缀而不是 <code>W1</code> ，那么就可能需要做千万次的匹配。</p> <p>本章后面会介绍另一个索引时的解决方案，这个方案能使前缀匹配更高效，不过在此之前，需要先看看两个相关的查询： <code>wildcard</code> 和 <code>regexp</code> （通配符和正则）。</p> <h4 id="_2-5-3-通配符和正则表达式查询"><a href="#_2-5-3-通配符和正则表达式查询" class="header-anchor">#</a> 2.5.3 通配符和正则表达式查询</h4> <p>与 <code>prefix</code> 前缀查询的特性类似， <code>wildcard</code> 通配符查询也是一种底层基于词的查询， 与前缀查询不同的是它允许指定匹配的正则式。它使用标准的 shell 通配符查询： <code>?</code> 匹配任意字符， <code>*</code> 匹配 0 或多个字符。</p> <p>这个查询会匹配包含 <code>W1F 7HW</code> 和 <code>W2F 8HW</code> 的文档：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/postcodes_test/address/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot;: {
        &quot;wildcard&quot;: {
            &quot;postcode&quot;: &quot;W?F*HW&quot; 
        }
    }
}
'
</code></pre></div><p>如果想匹配只以 <code>W</code> 开始并跟随一个数字的所有邮编， <code>regexp</code> 正则式查询允许写出这样更复杂的模式：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/postcodes_test/address/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot;: {
        &quot;regexp&quot;: {
            &quot;postcode&quot;: &quot;W[0-9].+&quot; 
        }
    }
}
'
</code></pre></div><p><code>wildcard</code> 和 <code>regexp</code> 查询的工作方式与 <code>prefix</code> 查询完全一样，它们也需要扫描倒排索引中的词列表才能找到所有匹配的词，然后依次获取每个词相关的文档 ID ，与 <code>prefix</code> 查询的唯一不同是：它们能支持更为复杂的匹配模式。</p> <p>这也意味着需要同样注意前缀查询存在性能问题，对有很多唯一词的字段执行这些查询可能会消耗非常多的资源，所以要避免使用左通配这样的模式匹配（如： <code>*foo</code> 或 <code>.*foo</code> 这样的正则式）。</p> <p>数据在索引时的预处理有助于提高前缀匹配的效率，而通配符和正则表达式查询只能在查询时完成，尽管这些查询有其应用场景，但使用仍需谨慎。</p> <p><code>prefix</code> 、 <code>wildcard</code> 和 <code>regexp</code> 查询是基于词操作的，如果用它们来查询 <code>text</code> 字段，它们会检查字段里面的每个词，而不是将字段作为整体来处理。</p> <p>比方说包含 “Quick brown fox” （快速的棕色狐狸）的 <code>title</code> 字段会生成词： <code>quick</code> 、 <code>brown</code> 和 <code>fox</code> 。</p> <p>会匹配以下这个查询：</p> <div class="language- extra-class"><pre class="language-text"><code>{ &quot;regexp&quot;: { &quot;title&quot;: &quot;br.*&quot; }}
</code></pre></div><p>但是不会匹配以下两个查询：</p> <div class="language- extra-class"><pre class="language-text"><code>{ &quot;regexp&quot;: { &quot;title&quot;: &quot;Qu.*&quot; }} 
{ &quot;regexp&quot;: { &quot;title&quot;: &quot;quick br*&quot; }} 
</code></pre></div><h4 id="_2-5-4-输入即搜索"><a href="#_2-5-4-输入即搜索" class="header-anchor">#</a> 2.5.4 输入即搜索</h4> <p>在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/phrase-matching.html" target="_blank" rel="noopener noreferrer">短语匹配<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中，我们引入了 <code>match_phrase</code> 短语匹配查询，它匹配相对顺序一致的所有指定词语，对于查询时的输入即搜索，可以使用 <code>match_phrase</code> 的一种特殊形式， <code>match_phrase_prefix</code> 查询：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;match_phrase_prefix&quot; : {
        &quot;brand&quot; : &quot;johnnie walker bl&quot;
    }
}
</code></pre></div><p>这种查询的行为与 <code>match_phrase</code> 查询一致，不同的是它将查询字符串的最后一个词作为前缀使用，换句话说，可以将之前的例子看成如下这样：</p> <ul><li><code>johnnie</code></li> <li>跟着 <code>walker</code></li> <li>跟着以 <code>bl</code> 开始的词</li></ul> <p>如果通过 <code>validate-query</code> API 运行这个查询查询，explanation 的解释结果为：</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;johnnie walker bl*&quot;
</code></pre></div><p>与 <code>match_phrase</code> 一样，它也可以接受 <code>slop</code> 参数（参照 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/slop.html" target="_blank" rel="noopener noreferrer">slop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ）让相对词序位置不那么严格：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;match_phrase_prefix&quot; : {
        &quot;brand&quot; : {
            &quot;query&quot;: &quot;walker johnnie bl&quot;, 
            &quot;slop&quot;:  10
        }
    }
}
</code></pre></div><p>尽管词语顺序不正确，查询仍然能匹配，因为我们为它设置了足够高的 <code>slop</code> 值使匹配时的词序有更大灵活性。
但是只有查询字符串的最后一个词才能当作前缀使用。
在之前的 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/prefix-query.html" target="_blank" rel="noopener noreferrer">前缀查询<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中，我们警告过使用前缀的风险，即 <code>prefix</code> 查询存在严重的资源消耗问题，短语查询的这种方式也同样如此。 前缀 <code>a</code> 可能会匹配成千上万的词，这不仅会消耗很多系统资源，而且结果的用处也不大。
可以通过设置 <code>max_expansions</code> 参数来限制前缀扩展的影响， 一个合理的值是可能是 50 ：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;match_phrase_prefix&quot; : {
        &quot;brand&quot; : {
            &quot;query&quot;:          &quot;johnnie walker bl&quot;,
            &quot;max_expansions&quot;: 50
        }
    }
}
</code></pre></div><h4 id="_2-5-5-索引时优化"><a href="#_2-5-5-索引时优化" class="header-anchor">#</a> 2.5.5 索引时优化</h4> <p>可以通过在索引时处理数据提高搜索的灵活性以及提升系统性能。为此仍然需要付出应有的代价：增加的索引空间与变慢的索引能力，但这与每次查询都需要付出代价不同，索引时的代价只用付出一次。</p> <p><em>n-grams</em>是一个在词语上的滑动窗口 ， n 代表这个 “窗口” 的长度。</p> <p>如果我们要 n-gram <code>quick</code> 这个词 —— 它的结果取决于 <em>n</em> 的选择长度：</p> <ul><li>长度 1（unigram）： [ <code>q</code>, <code>u</code>, <code>i</code>, <code>c</code>, <code>k</code> ]</li> <li>长度 2（bigram）： [ <code>qu</code>, <code>ui</code>, <code>ic</code>, <code>ck</code> ]</li> <li>长度 3（trigram）： [ <code>qui</code>, <code>uic</code>, <code>ick</code> ]</li> <li>长度 4（four-gram）： [ <code>quic</code>, <code>uick</code> ]</li> <li>长度 5（five-gram）： [ <code>quick</code> ]</li></ul> <p>朴素的 n-gram 对 <em>词语内部的匹配</em> 非常有用，即在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/ngrams-compound-words.html" target="_blank" rel="noopener noreferrer">Ngram 匹配复合词<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 介绍的那样。但对于输入即搜索（search-as-you-type）这种应用场景，我们会使用一种特殊的 n-gram 称为 <em>边界 n-grams</em> （edge n-grams）。所谓的边界 n-gram 是说它会固定词语开始的一边，以单词 <code>quick</code> 为例，它的边界 n-gram 的结果为：</p> <ul><li><code>q</code></li> <li><code>qu</code></li> <li><code>qui</code></li> <li><code>quic</code></li> <li><code>quick</code></li></ul> <p>可能会注意到这与用户在搜索时输入 “quick” 的字母次序是一致的，换句话说，这种方式正好满足即时搜索（instant search）！</p> <h4 id="_2-5-6-索引时输入即搜索"><a href="#_2-5-6-索引时输入即搜索" class="header-anchor">#</a> 2.5.6 索引时输入即搜索</h4> <p><strong>准备索引</strong></p> <p>第一步需要配置一个自定义的 <code>edge_ngram</code> token 过滤器，称为 <code>autocomplete_filter</code> ：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;filter&quot;: {
        &quot;autocomplete_filter&quot;: {
            &quot;type&quot;:     &quot;edge_ngram&quot;,
            &quot;min_gram&quot;: 1,
            &quot;max_gram&quot;: 20
        }
    }
}
</code></pre></div><p>这个配置的意思是：对于这个 token 过滤器接收的任意词项，过滤器会为之生成一个最小固定值为 1 ，最大为 20 的 n-gram 。</p> <p>然后会在一个自定义分析器 <code>autocomplete</code> 中使用上面这个 token 过滤器：</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;analyzer&quot;: {
        &quot;autocomplete&quot;: {
            &quot;type&quot;:      &quot;custom&quot;,
            &quot;tokenizer&quot;: &quot;standard&quot;,
            &quot;filter&quot;: [
                &quot;lowercase&quot;,
                &quot;autocomplete_filter&quot; 
            ]
        }
    }
}
</code></pre></div><p>这个分析器使用 <code>standard</code> 分词器将字符串拆分为独立的词，并且将它们都变成小写形式，然后为每个词生成一个边界 n-gram，这要感谢 <code>autocomplete_filter</code> 起的作用。</p> <p>创建索引、实例化 token 过滤器和分析器的完整示例如下：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;localhost:9200/my_index&quot; -H 'Content-Type: application/json' -d'
{
    &quot;settings&quot;: {
        &quot;number_of_shards&quot;: 1, 
        &quot;analysis&quot;: {
            &quot;filter&quot;: {
                &quot;autocomplete_filter&quot;: { 
                    &quot;type&quot;:     &quot;edge_ngram&quot;,
                    &quot;min_gram&quot;: 1,
                    &quot;max_gram&quot;: 20
                }
            },
            &quot;analyzer&quot;: {
                &quot;autocomplete&quot;: {
                    &quot;type&quot;:      &quot;custom&quot;,
                    &quot;tokenizer&quot;: &quot;standard&quot;,
                    &quot;filter&quot;: [
                        &quot;lowercase&quot;,
                        &quot;autocomplete_filter&quot; 
                    ]
                }
            }
        }
    }
}
'
</code></pre></div><p>可以拿 <code>analyze</code> API 测试这个新的分析器确保它行为正确：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -XGET &quot;http://172.16.20.64:39200/my_index/_analyze&quot; -H 'Content-Type: application/json' -d'
{
  &quot;analyzer&quot;: &quot;autocomplete&quot;,
  &quot;text&quot;: &quot;quick brown&quot;
}'
</code></pre></div><p>结果表明分析器能正确工作，并返回以下词：</p> <ul><li><code>q</code></li> <li><code>qu</code></li> <li><code>qui</code></li> <li><code>quic</code></li> <li><code>quick</code></li> <li><code>b</code></li> <li><code>br</code></li> <li><code>bro</code></li> <li><code>brow</code></li> <li><code>brown</code></li></ul> <p>可以用 <code>update-mapping</code> API 将这个分析器应用到具体字段：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;localhost:9200/my_index/_mapping/my_type&quot; -H 'Content-Type: application/json' -d'
{
    &quot;my_type&quot;: {
        &quot;properties&quot;: {
            &quot;name&quot;: {
                &quot;type&quot;:     &quot;text&quot;,
                &quot;analyzer&quot;: &quot;autocomplete&quot;
            }
        }
    }
}
'
</code></pre></div><p>创建一些测试文档</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X POST &quot;localhost:9200/my_index/my_type/_bulk&quot; -H 'Content-Type: application/json' -d'
{ &quot;index&quot;: { &quot;_id&quot;: 1            }}
{ &quot;name&quot;: &quot;Brown foxes&quot;    }
{ &quot;index&quot;: { &quot;_id&quot;: 2            }}
{ &quot;name&quot;: &quot;Yellow furballs&quot; }
'
</code></pre></div><p>如果使用简单 <code>match</code> 查询测试查询 “brown fo” ：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/my_index/my_type/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;name&quot;: &quot;brown fo&quot;
        }
    }
}
'
</code></pre></div><p>结果是两个文档同时都能匹配，尽管 Yellow furballs 这个文档并不包含 brown 和 fo 。</p> <p>如往常一样， <code>validate-query</code> API 总能提供一些线索：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/my_index/my_type/_validate/query?explain&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;name&quot;: &quot;brown fo&quot;
        }
    }
}
'
</code></pre></div><p><code>explanation</code> 表明查询会查找边界 n-grams 里的每个词：</p> <div class="language- extra-class"><pre class="language-text"><code>name:b name:br name:bro name:brow name:brown name:f name:fo
</code></pre></div><p><code>name:f</code> 条件可以满足第二个文档，因为 <code>furballs</code> 是以 <code>f</code> 、 <code>fu</code> 、 <code>fur</code> 形式索引的。回过头看这并不令人惊讶，相同的 <code>autocomplete</code> 分析器同时被应用于索引时和搜索时，这在大多数情况下是正确的，只有在少数场景下才需要改变这种行为。</p> <p>我们需要保证倒排索引表中包含边界 n-grams 的每个词，但是我们只想匹配用户输入的完整词组（ <code>brown</code>和 <code>fo</code> ）， 可以通过在索引时使用 <code>autocomplete</code> 分析器，并在搜索时使用 <code>standard</code> 标准分析器来实现这种想法，只要改变查询使用的搜索分析器 <code>analyzer</code> 参数即可：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X GET &quot;localhost:9200/my_index/my_type/_search&quot; -H 'Content-Type: application/json' -d'
{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;name&quot;: {
                &quot;query&quot;:    &quot;brown fo&quot;,
                &quot;analyzer&quot;: &quot;standard&quot; 
            }
        }
    }
}
'
</code></pre></div><p>换种方式，我们可以在映射中，为 <code>name</code> 字段分别指定 <code>index_analyzer</code> 和 <code>search_analyzer</code> 。因为我们只想改变 <code>search_analyzer</code> ，这里只要更新现有的映射而不用对数据重新创建索引：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -XPUT &quot;http://172.16.20.64:39200/my_index/my_type/_mapping&quot; -H 'Content-Type: application/json' -d'
{
  &quot;my_type&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;autocomplete&quot;,
        &quot;search_analyzer&quot;: &quot;standard&quot;
      }
    }
  }
}'
</code></pre></div><p>因为大多数工作是在索引时完成的，所有的查询只要查找 <code>brown</code> 和 <code>fo</code> 这两个词，这比使用 <code>match_phrase_prefix</code> 查找所有以 <code>fo</code> 开始的词的方式要高效许多。</p> <p><strong>补全提示（Completion Suggester）</strong></p> <blockquote><p>Elasticsearch 里的 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-completion.html" target="_blank" rel="noopener noreferrer">completion suggester<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 采用与上面完全不同的方式，需要为搜索条件生成一个所有可能完成的词列表，然后将它们置入一个 <em>有限状态机（finite state transducer）</em> 内，这是个经优化的图结构。为了搜索建议提示，Elasticsearch 从图的开始处顺着匹配路径一个字符一个字符地进行匹配，一旦它处于用户输入的末尾，Elasticsearch 就会查找所有可能结束的当前路径，然后生成一个建议列表。</p> <p>本数据结构存于内存中，能使前缀查找非常快，比任何一种基于词的查询都要快很多，这对名字或品牌的自动补全非常适用，因为这些词通常是以普通顺序组织的：用 “Johnny Rotten” 而不是 “Rotten Johnny” 。</p> <p>当词序不是那么容易被预见时，边界 n-grams 比完成建议者（Completion Suggester）更合适。</p></blockquote> <p><strong>边界n-grams与邮编</strong></p> <p>边界 n-gram 的方式可以用来查询结构化的数据， 比如本章之前示例中的邮编（postcode）。当然 <code>postcode</code> 字段需要 text而不是keyword ，不过可以用 <code>keyword</code> 分词器来处理它，就好像他们是 text的一样。</p> <blockquote><p><code>keyword</code> 分词器是一个非操作型分词器，这个分词器不做任何事情，它接收的任何字符串都会被原样发出，因此它可以用来处理keyword的字段值，但这也需要其他的一些分析转换，如将字母转换成小写。</p></blockquote> <p>下面示例使用 <code>keyword</code> 分词器将邮编转换成 token 流，这样就能使用边界 n-gram token 过滤器：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -XPUT &quot;http://172.16.20.64:39200/postcodes_test&quot; -H 'Content-Type: application/json' -d'
{
  &quot;settings&quot;: {
    &quot;number_of_shards&quot;: 1,
    &quot;analysis&quot;: {
      &quot;filter&quot;: {
        &quot;postcode_filter&quot;: {
          &quot;type&quot;: &quot;edge_ngram&quot;,
          &quot;min_gram&quot;: 1,
          &quot;max_gram&quot;: 8
        }
      },
      &quot;analyzer&quot;: {
        &quot;postcode_index&quot;: {
          &quot;tokenizer&quot;: &quot;keyword&quot;,
          &quot;filter&quot;: [
            &quot;postcode_filter&quot;
          ]
        },
        &quot;postcode_search&quot;: {
          &quot;tokenizer&quot;: &quot;keyword&quot;
        }
      }
    }
  }
}'
</code></pre></div><h4 id="_2-5-7-ngrams-在复合词的应用"><a href="#_2-5-7-ngrams-在复合词的应用" class="header-anchor">#</a> 2.5.7 Ngrams 在复合词的应用</h4> <p>最后，来看看 n-gram 是如何应用于搜索复合词的语言中的。 德语的特点是它可以将许多小词组合成一个庞大的复合词以表达它准确或复杂的意义。例如：</p> <ul><li><p><em>Aussprachewörterbuch</em></p> <p>发音字典（Pronunciation dictionary）</p></li> <li><p><em>Militärgeschichte</em></p> <p>战争史（Military history）</p></li> <li><p><em>Weißkopfseeadler</em></p> <p>秃鹰（White-headed sea eagle, or bald eagle）</p></li> <li><p><em>Weltgesundheitsorganisation</em></p> <p>世界卫生组织（World Health Organization）</p></li> <li><p><em>Rindfleischetikettierungsüberwachungsaufgabenübertragungsgesetz</em></p> <p>法案考虑代理监管牛和牛肉的标记的职责（The law concerning the delegation of duties for the supervision of cattle marking and the labeling of beef）</p></li></ul> <p>有些人希望在搜索 “Wörterbuch”（字典）的时候，能在结果中看到 “Aussprachewörtebuch”（发音字典）。同样，搜索 “Adler”（鹰）的时候，能将 “Weißkopfseeadler”（秃鹰）包括在结果中。</p> <p>处理这种语言的一种方式可以用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-compound-word-tokenfilter.html" target="_blank" rel="noopener noreferrer">组合词 token 过滤器（compound word token filter）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 将复合词拆分成各自部分，但这种方式的结果质量依赖于组合词字典的质量。</p> <p>另一种方式就是将所有的词用 n-gram 进行处理，然后搜索任何匹配的片段——能匹配的片段越多，文档的相关度越大。</p> <p>假设某个 n-gram 是一个词上的滑动窗口，那么任何长度的 n-gram 都可以遍历这个词。我们既希望选择足够长的值让拆分的词项具有意义，又不至于因为太长而生成过多的唯一词。一个长度为 3 的 <em>trigram</em> 可能是一个不错的开始：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -X PUT &quot;localhost:9200/my_index&quot; -H 'Content-Type: application/json' -d'
{
    &quot;settings&quot;: {
        &quot;analysis&quot;: {
            &quot;filter&quot;: {
                &quot;trigrams_filter&quot;: {
                    &quot;type&quot;:     &quot;ngram&quot;,
                    &quot;min_gram&quot;: 3,
                    &quot;max_gram&quot;: 3
                }
            },
            &quot;analyzer&quot;: {
                &quot;trigrams&quot;: {
                    &quot;type&quot;:      &quot;custom&quot;,
                    &quot;tokenizer&quot;: &quot;standard&quot;,
                    &quot;filter&quot;:   [
                        &quot;lowercase&quot;,
                        &quot;trigrams_filter&quot;
                    ]
                }
            }
        }
    },
    &quot;mappings&quot;: {
        &quot;my_type&quot;: {
            &quot;properties&quot;: {
                &quot;text&quot;: {
                    &quot;type&quot;:     &quot;string&quot;,
                    &quot;analyzer&quot;: &quot;trigrams&quot; 
                }
            }
        }
    }
}
'
</code></pre></div><p>使用 <code>analyze</code> API 测试 trigram 分析器：</p> <div class="language- extra-class"><pre class="language-text"><code>curl -XGET &quot;http://172.16.20.64:39200/my_index/_analyze&quot; -H 'Content-Type: application/json' -d'
{
  &quot;analyzer&quot;: &quot;trigrams&quot;,
  &quot;text&quot;: &quot;Weißkopfseeadler&quot;
}'
</code></pre></div><p>返回以下词项：</p> <div class="language- extra-class"><pre class="language-text"><code>wei, eiß, ißk, ßko, kop, opf, pfs, fse, see, eea,ead, adl, dle, ler
</code></pre></div><p>索引前述示例中的复合词来测试：</p> <div class="language- extra-class"><pre class="language-text"><code>POST /my_index/my_type/_bulk
{ &quot;index&quot;: { &quot;_id&quot;: 1 }}
{ &quot;text&quot;: &quot;Aussprachewörterbuch&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: 2 }}
{ &quot;text&quot;: &quot;Militärgeschichte&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: 3 }}
{ &quot;text&quot;: &quot;Weißkopfseeadler&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: 4 }}
{ &quot;text&quot;: &quot;Weltgesundheitsorganisation&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: 5 }}
{ &quot;text&quot;: &quot;Rindfleischetikettierungsüberwachungsaufgabenübertragungsgesetz&quot; }
</code></pre></div><p>“Adler”（鹰）的搜索转化为查询三个词 <code>adl</code> 、 <code>dle</code> 和 <code>ler</code> ：</p> <div class="language- extra-class"><pre class="language-text"><code>GET /my_index/my_type/_search
{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;text&quot;: &quot;Adler&quot;
        }
    }
}
</code></pre></div><p>正好与 “Weißkopfsee-<em>adler</em>” 相匹配：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;hits&quot;: [
     {
        &quot;_id&quot;: &quot;3&quot;,
        &quot;_score&quot;: 3.3191128,
        &quot;_source&quot;: {
           &quot;text&quot;: &quot;Weißkopfseeadler&quot;
        }
     }
  ]
}
</code></pre></div><p>类似查询 “Gesundheit”（健康）可以与 “Welt-gesundheit-sorganisation” 匹配，同时也能与 “Militär-<em>ges</em>-chichte” 和 “Rindfleischetikettierungsüberwachungsaufgabenübertragungs-<em>ges</em>-etz” 匹配，因为它们同时都有 trigram 生成的 <code>ges</code> ：</p> <p>使用合适的 <code>minimum_should_match</code> 可以将这些奇怪的结果排除，只有当 trigram 最少匹配数满足要求时，文档才能被认为是匹配的：</p> <div class="language- extra-class"><pre class="language-text"><code>GET /my_index/my_type/_search
{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;text&quot;: {
                &quot;query&quot;:                &quot;Gesundheit&quot;,
                &quot;minimum_should_match&quot;: &quot;80%&quot;
            }
        }
    }
}
</code></pre></div><p>这有点像全文搜索中霰弹枪式的策略，可能会导致倒排索引内容变多，尽管如此，在索引具有很多复合词的语言，或词之间没有空格的语言（如：泰语）时，它仍不失为一种通用且有效的方法。</p> <p>这种技术可以用来提升 <em>召回率</em> ——搜索结果中相关的文档数。它通常会与其他技术一起使用，例如 shingles（参见 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/shingles.html" target="_blank" rel="noopener noreferrer">shingles 瓦片词<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ），以提高精度和每个文档的相关度评分。</p> <h2 id="_4、聚合"><a href="#_4、聚合" class="header-anchor">#</a> 4、聚合</h2> <h3 id="_4-3-条形图"><a href="#_4-3-条形图" class="header-anchor">#</a> 4.3 条形图</h3> <p>&quot;以最受欢迎 10 种汽车以及它们的平均售价、标准差这些信息创建一个条形图&quot;这个例子的代码执行报错</p> <div class="language- extra-class"><pre class="language-text"><code>    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;illegal_argument_exception&quot;,
        &quot;reason&quot;: &quot;Fielddata is disabled on text fields by default. Set fielddata=true on [make] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.&quot;
      }
    ]
</code></pre></div><p>报错信息里边已经给出了解决方案，需要把make字段设置为keyword类型。</p> <div class="language- extra-class"><pre class="language-text"><code>PUT /cars/_mapping/transactions
{
  &quot;properties&quot;: {
    &quot;price&quot;: {
      &quot;type&quot;: &quot;long&quot;
    },
    &quot;color&quot;:{
      &quot;type&quot;: &quot;keyword&quot;
    },
    &quot;make&quot;:{
      &quot;type&quot;: &quot;keyword&quot;
    },
    &quot;sold&quot;:{
      &quot;type&quot;: &quot;date&quot;
    }
  }
}
</code></pre></div><p>执行以上语句会报另一个错：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;index_not_found_exception&quot;,
        &quot;reason&quot;: &quot;no such index&quot;,
        &quot;index_uuid&quot;: &quot;_na_&quot;,
        &quot;resource.type&quot;: &quot;index_or_alias&quot;,
        &quot;resource.id&quot;: &quot;cars&quot;,
        &quot;index&quot;: &quot;cars&quot;
      }
    ],
    &quot;type&quot;: &quot;index_not_found_exception&quot;,
    &quot;reason&quot;: &quot;no such index&quot;,
    &quot;index_uuid&quot;: &quot;_na_&quot;,
    &quot;resource.type&quot;: &quot;index_or_alias&quot;,
    &quot;resource.id&quot;: &quot;cars&quot;,
    &quot;index&quot;: &quot;cars&quot;
  },
  &quot;status&quot;: 404
}
</code></pre></div><p>google可知，需要先创建一个空的Index</p> <div class="language- extra-class"><pre class="language-text"><code>PUT cars 
{}
</code></pre></div><p>这次就可以愉快的用书中的例子来玩耍了。</p> <p>其实还有更简单的方式，只需要把书中的make改为make.keyword就可以了</p> <div class="language- extra-class"><pre class="language-text"><code>GET /cars/transactions/_search
{
  &quot;size&quot; : 0,
  &quot;aggs&quot;: {
    &quot;makes&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;make.keyword&quot;,
        &quot;size&quot;: 10
      },
      &quot;aggs&quot;: {
        &quot;stats&quot;: {
          &quot;extended_stats&quot;: {
            &quot;field&quot;: &quot;price&quot;
          }
        }
      }
    }
  }
}
</code></pre></div><h3 id="_4-6-过滤和聚合"><a href="#_4-6-过滤和聚合" class="header-anchor">#</a> 4.6 过滤和聚合</h3> <h4 id="_4-6-3-后过滤器"><a href="#_4-6-3-后过滤器" class="header-anchor">#</a> 4.6.3 后过滤器</h4> <p>感觉书上的例子不够清晰，不如这个</p> <div class="language- extra-class"><pre class="language-text"><code>GET /cars/transactions/_search
{
    &quot;size&quot; : 1,
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;make&quot;: &quot;ford&quot;
        }
    },
    &quot;post_filter&quot;: {    
        &quot;term&quot; : {
            &quot;color&quot; : &quot;green&quot;
        }
    },
    &quot;aggs&quot; : {
        &quot;all_colors&quot;: {
            &quot;terms&quot; : { &quot;field&quot; : &quot;color.keyword&quot; }
        }
    }
}
</code></pre></div><h3 id="_4-8-近似聚合"><a href="#_4-8-近似聚合" class="header-anchor">#</a> 4.8 近似聚合</h3> <h4 id="_4-8-1-统计去重后的数量"><a href="#_4-8-1-统计去重后的数量" class="header-anchor">#</a> 4.8.1 统计去重后的数量</h4> <p><strong>速度优化</strong></p> <p>这一节提到了通过在索引时就计算hash来提高性能</p> <div class="language- extra-class"><pre class="language-text"><code>PUT /cars/
{
  &quot;mappings&quot;: {
    &quot;transactions&quot;: {
      &quot;properties&quot;: {
        &quot;color&quot;: {
          &quot;type&quot;: &quot;keyword&quot;,
          &quot;fields&quot;: {
            &quot;hash&quot;: {
              &quot;type&quot;: &quot;murmur3&quot;
            }
          }
        }
      }
    }
  }
}
</code></pre></div><p>但是直接运行，会报错</p> <div class="language- extra-class"><pre class="language-text"><code>no handler for type [murmur3] declared on field [hash]
</code></pre></div><p>原因是没有安装murmur3插件，通过下面这个命令可以查看已安装的插件</p> <div class="language- extra-class"><pre class="language-text"><code>GET /_cat/plugins?v
</code></pre></div><p>而这篇官方文档讲了如何安装murmur3插件：<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/mapper-murmur3.html" target="_blank" rel="noopener noreferrer">murmur3插件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_4-10-doc-values-and-fielddata"><a href="#_4-10-doc-values-and-fielddata" class="header-anchor">#</a> 4.10 Doc values and Fielddata</h3> <h4 id="_4-10-3-聚合与分析"><a href="#_4-10-3-聚合与分析" class="header-anchor">#</a> 4.10.3 聚合与分析</h4> <p>Fielddata在当前版本（es 6.5）默认是禁用的。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">1/14/2020, 2:00:10 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/5.html" class="prev">
        ES6学习笔记
      </a></span> <span class="next"><a href="/database/mongodb.html">
        MongoDB分片介绍
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d45e7d8d.js" defer></script><script src="/assets/js/3.f201c9f2.js" defer></script><script src="/assets/js/2.58f2d4b3.js" defer></script><script src="/assets/js/35.066a2949.js" defer></script>
  </body>
</html>
