(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{236:function(t,e,s){t.exports=s.p+"assets/img/1.bdf0c428.png"},237:function(t,e,s){t.exports=s.p+"assets/img/2.7dca815b.png"},326:function(t,e,s){"use strict";s.r(e);var n=s(0),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"观察者、中介者"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#观察者、中介者"}},[t._v("#")]),t._v(" 观察者、中介者")]),t._v(" "),n("p",[n("strong",[t._v("观察者")])]),t._v(" "),n("p",[t._v("这个实现应该是超级简单了，被观察者拥有观察者列表，可以通知到它们，而观察者都要实现同一个响应接口\n"),n("img",{attrs:{src:s(236),alt:""}})]),t._v(" "),n("p",[n("strong",[t._v("中介者")])]),t._v(" "),n("p",[t._v("中介者和观察者其实非常像了，只是前者的对象都可以notify其他对象，而后者只有一个对象可以notify而已。\n毫无疑问，中介者中用list保存了所有参与的对象（uml图中称为college），\n而所有的对象也都依赖了中介者，都实现了send和receive方法，send方法就是调中介者的relay（转发）方法而已，\n一旦中介者的relay方法被调用，relay方法内部又会调所有对象的receive方法。\n"),n("img",{attrs:{src:s(237),alt:""}})])])}),[],!1,null,null,null);e.default=r.exports}}]);