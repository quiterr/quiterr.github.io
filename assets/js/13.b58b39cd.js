(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{218:function(t,s,e){t.exports=e.p+"assets/img/1.8aab729e.png"},219:function(t,s,e){t.exports=e.p+"assets/img/2.fe6fdeef.png"},220:function(t,s,e){t.exports=e.p+"assets/img/3.30bff770.png"},332:function(t,s,e){"use strict";e.r(s);var n=e(0),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"单例、原型、工厂、建造者"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#单例、原型、工厂、建造者"}},[t._v("#")]),t._v(" 单例、原型、工厂、建造者")]),t._v(" "),n("p",[n("strong",[t._v("单例")])]),t._v(" "),n("p",[t._v("分为懒汉和饿汉两种，饿汉是用static在类加载的时候就创建好对象，不存在线程安全性问题。懒汉是在调用getInstance方法时才创建对象，存在线程安全问题，需要加锁。两者都不提供公有的构造方法，避免外部创建多个实例。")]),t._v(" "),n("p",[n("strong",[t._v("原型")])]),t._v(" "),n("p",[t._v("java有现成的Cloneable接口，需要实现它。java的object类实现了clone方法，可以做浅克隆。\n浅克隆只能克隆对象的属性，如果属性是引用类型，则需要深克隆，一般用对象序列化来实现。")]),t._v(" "),n("p",[n("strong",[t._v("工厂方法")])]),t._v(" "),n("p",[t._v("创建一种产品，目的是使创建和使用分离，实现只需要记住一张图即可：\n"),n("img",{attrs:{src:e(218),alt:""}})]),t._v(" "),n("p",[t._v("如果只有一个工厂，就退化成了简单工厂模式。")]),t._v(" "),n("p",[n("strong",[t._v("抽象工厂")])]),t._v(" "),n("p",[t._v("可以创建多种产品\n"),n("img",{attrs:{src:e(219),alt:""}})]),t._v(" "),n("p",[n("strong",[t._v("建造者")])]),t._v(" "),n("p",[t._v("用于构造复杂的对象，只要记住包括对象、builder、director三大组件就好实现了，三者关系是director包含builder，builder包含对象。\n如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。\n"),n("img",{attrs:{src:e(220),alt:""}})])])}),[],!1,null,null,null);s.default=r.exports}}]);