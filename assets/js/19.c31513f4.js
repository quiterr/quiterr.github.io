(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{234:function(t,n,s){t.exports=s.p+"assets/img/1.56e3ea76.png"},235:function(t,n,s){t.exports=s.p+"assets/img/2.d9fb2e92.png"},327:function(t,n,s){"use strict";s.r(n);var e=s(0),a=Object(e.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"责任链、状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#责任链、状态"}},[t._v("#")]),t._v(" 责任链、状态")]),t._v(" "),e("p",[e("strong",[t._v("责任链")])]),t._v(" "),e("p",[t._v("责任链没有什么难的，注意负责处理的对象是提前创建好、设置好的，有多少个处理者，就要创建多少个，并且把next设置好。\n还有就是注意处理者都是继承同一个抽象类，这个抽象类有处理方法和next。\n"),e("img",{attrs:{src:s(234),alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("状态")])]),t._v(" "),e("p",[t._v("状态模式和命令模式比较像，前者专门把状态提取出来做成对象，后者也专门把命令提取出来做对象。\nhead first中的糖果机有四种状态：没有25分钱（投入25分钱） -> 有25分钱（转动手柄） -> 售出糖果 -> 糖果售罄，不用状态模式会写很多的if语句，\n实现了状态对象之后，还要实现糖果机，在糖果机内部有4个状态的实例对象和剩余糖果的数量，并且也实现了状态的4个方法（简单的调state的对应方法）。状态对象执行完自己的操作后，要设置糖果机的状态。\n"),e("img",{attrs:{src:s(235),alt:""}})]),t._v(" "),e("p",[t._v("教程里边线程有新建、就绪、运行、阻塞、停止等状态，这些状态都继承自线程抽象状态类，但线程抽象状态类实际上并没有handle接口，只有一个name，具体线程状态中实现的是不同的handle方法，在环境类中调这些不同的handle方法。（按照head first的思路，就不是这么做了，抽象状态类里边有所有的操作才对，更赞同这种思路。如果看jdk源码会发现Thread不像是用状态模式做的，这是因为真正管理线程的是操作系统，而不是我们常用的Thread，我们实际上只能调用start(), wait(), notify()这几个）而且jdk里边也没有running这个状态，jdk的线程状态和操作系统的线程状态不是等价的。\n"),e("img",{attrs:{src:"img/7/3.png",alt:""}})])])}),[],!1,null,null,null);n.default=a.exports}}]);