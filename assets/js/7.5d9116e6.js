(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{259:function(t,a,e){t.exports=e.p+"assets/img/syn-block.5838b6ed.png"},260:function(t,a,e){t.exports=e.p+"assets/img/volatile-long.b0f79a13.png"},261:function(t,a,e){t.exports=e.p+"assets/img/LongCounter.a7004cd3.png"},262:function(t,a,e){t.exports=e.p+"assets/img/countdownlatch.6dbce9c6.png"},263:function(t,a,e){t.exports=e.p+"assets/img/mpsc.ac9e2e47.png"},264:function(t,a,e){t.exports=e.p+"assets/img/serial.75ccfac7.png"},265:function(t,a,e){t.exports=e.p+"assets/img/parallel.886eb9b2.png"},266:function(t,a,e){t.exports=e.p+"assets/img/threadLocal.cc9af66a.png"},312:function(t,a,e){"use strict";e.r(a);var n=e(0),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"netty中的锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty中的锁"}},[t._v("#")]),t._v(" netty中的锁")]),t._v(" "),n("p"),n("div",{staticClass:"table-of-contents"},[n("ul",[n("li",[n("a",{attrs:{href:"#注意锁的范围"}},[t._v("注意锁的范围")])]),n("li",[n("a",{attrs:{href:"#注意锁的大小"}},[t._v("注意锁的大小")])]),n("li",[n("a",{attrs:{href:"#注意锁的速度"}},[t._v("注意锁的速度")])]),n("li",[n("a",{attrs:{href:"#不同场景选择不同的并发包"}},[t._v("不同场景选择不同的并发包")])]),n("li",[n("a",{attrs:{href:"#能不用锁就不用锁"}},[t._v("能不用锁就不用锁")])])])]),n("p"),t._v(" "),n("h2",{attrs:{id:"注意锁的范围"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意锁的范围"}},[t._v("#")]),t._v(" 注意锁的范围")]),t._v(" "),n("p",[t._v("这个例子涉及的代码已经被重构了，但是非常经典，启示是尽量减小加锁的范围，来自io.netty.bootstrap.ServerBootstrap#init：\n"),n("img",{attrs:{src:e(259),alt:""}})]),t._v(" "),n("h2",{attrs:{id:"注意锁的大小"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意锁的大小"}},[t._v("#")]),t._v(" 注意锁的大小")]),t._v(" "),n("p",[t._v("第二个例子来自io.netty.channel.ChannelOutboundBuffer，不过实际我并没有找到相关代码，可能也重构了。它是用Volatile long + AtomicLongFieldUpdater来替代AtomicLong，节省内存：\n"),n("img",{attrs:{src:e(260),alt:""}})]),t._v(" "),n("h2",{attrs:{id:"注意锁的速度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意锁的速度"}},[t._v("#")]),t._v(" 注意锁的速度")]),t._v(" "),n("p",[t._v("记录内存分配字节数等功能用到的LongCounter（io.netty.util.internal.PlatformDependent#newLongCounter()） 。这是一个写比读多的场景，JDK8以后基于LongAdder实现的LongAdderCounter性能要优于AtomicLongCounter:\n"),n("img",{attrs:{src:e(261),alt:""}})]),t._v(" "),n("h2",{attrs:{id:"不同场景选择不同的并发包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不同场景选择不同的并发包"}},[t._v("#")]),t._v(" 不同场景选择不同的并发包")]),t._v(" "),n("p",[t._v("使用CountDownLatch替代wait/notify，因为后者必须要结合锁来用，实际用起来比较麻烦，io.netty.util.concurrent.SingleThreadEventExecutor#threadLock：\n"),n("img",{attrs:{src:e(262),alt:""}})]),t._v(" "),n("p",[t._v("NioEventLoop中负责存储task的Queue，JDK中的实现是LinkedBlockingQueue(MPMC)，netty用的是jctools的MPSC，因为场景就是多个生产者，单个消费者。\n"),n("img",{attrs:{src:e(263),alt:""}})]),t._v(" "),n("h2",{attrs:{id:"能不用锁就不用锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#能不用锁就不用锁"}},[t._v("#")]),t._v(" 能不用锁就不用锁")]),t._v(" "),n("p",[t._v("局部串行：Channel 的 I/O 请求处理 Pipeline 是串行的\n"),n("img",{attrs:{src:e(264),alt:""}})]),t._v(" "),n("p",[t._v("整体并行：多个串行化的线程（NioEventLoop）。注意这个图中的一个线程画了3个channel，也就是说一个EventLoop线程可能处理不同的channel，channel注册到EventLoopGroup，具体哪个EventLoop处理哪个channel是按线程池中的任务队列来的。\n"),n("img",{attrs:{src:e(265),alt:""}})]),t._v(" "),n("p",[t._v("避免用锁：用 ThreadLocal 来避免资源争用，例如 Netty 轻量级的线程池实现\nio.netty.util.Recycler#threadLocal\n"),n("img",{attrs:{src:e(266),alt:""}})])])}),[],!1,null,null,null);a.default=s.exports}}]);