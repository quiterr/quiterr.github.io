(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{221:function(t,s,n){t.exports=n.p+"assets/img/1.105fd46d.png"},222:function(t,s,n){t.exports=n.p+"assets/img/2.bc736f3a.png"},223:function(t,s,n){t.exports=n.p+"assets/img/3.a4201c8d.png"},331:function(t,s,n){"use strict";n.r(s);var e=n(0),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"代理、适配器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理、适配器"}},[t._v("#")]),t._v(" 代理、适配器")]),t._v(" "),e("p",[e("strong",[t._v("代理模式")])]),t._v(" "),e("p",[t._v("代理模式本身很简单，只是真正应用的时候，是用的动态代理。\n在代理类里边有目标类的实例，这个和适配器是一样的（对象适配器也要有目标对象），区别在于代理类嵌入了preRequest、postRequest，适配器不会。\n知识扩展：JDK有Proxy类和InvocationHandler接口，可以比较方便的实现接口级别的动态代理\n"),e("img",{attrs:{src:n(221),alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("适配器")])]),t._v(" "),e("p",[t._v("分为类适配和对象适配，类适配需要实现目标接口，同时继承目标类，扩展性不如对象适配。\n"),e("img",{attrs:{src:n(222),alt:""}}),t._v(" "),e("img",{attrs:{src:n(223),alt:""}})])])}),[],!1,null,null,null);s.default=r.exports}}]);