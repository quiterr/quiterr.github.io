(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{314:function(a,t,s){"use strict";s.r(t);var n=s(0),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"hashmap和threadlocal的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap和threadlocal的实现原理"}},[a._v("#")]),a._v(" HashMap和ThreadLocal的实现原理")]),a._v(" "),s("p",[a._v("HashMap和ThreadLocal的实现原理是面试中的常考题目，不过本篇并不打算写太细，因为已经有人写得很好了。比如：")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"http://www.jasongj.com/java/concurrenthashmap/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java进阶（六）从ConcurrentHashMap的演进看Java多线程核心技术"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"http://www.jasongj.com/java/threadlocal/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java进阶（七）正确理解Thread Local的原理与适用场景"),s("OutboundLink")],1)])]),a._v(" "),s("p",[a._v("顺便说一句，光看别人的文章不够，还是要结合源码来看才能理解透彻。")]),a._v(" "),s("h2",{attrs:{id:"hashmap的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的实现原理"}},[a._v("#")]),a._v(" HashMap的实现原理")]),a._v(" "),s("p",[a._v("HashMap的内部数据结构是数组和链表，初始化的时候可以指定capacity，如果不是2的N次方，内部会使用一个比指定的数大的满足2的N次方的数。")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),s("p",[a._v("capacity 既是HashMap的容量也是内部数组的最大长度，还有一个size，每次put、remove之后size都会变，只有初始化和resize时capacity才会变。")])]),a._v(" "),s("p",[a._v("put操作时，key先计算hashCode，再对capacity取余，由于capacity是2的N次方，实现时用位运算替代取余达到更高的性能。put操作结束的时候，size自增，如果大于threshold就执行resize方法。threshold等于capacity*loadFactor，后者默认是0.75。")]),a._v(" "),s("p",[a._v("理论上，不执行resize方法也可以，因为链表可以无限加长，但是这违背了HashMap设计初衷，数组的寻址效率是O(1)，链表寻址效率是O(n)。")]),a._v(" "),s("p",[a._v("HashMap执行resize时就是新创建一个capacity*2的table，然后将原来的数据重新put到新table。在JDK7的版本，遍历链表的时候会将链表倒置，当两个线程并发执行的时候，可能会发生两次倒置形成链表循环，下次再遍历链表就会"),s("strong",[a._v("死循环")]),a._v("。")]),a._v(" "),s("p",[a._v("为了减少hashCode的冲突（也即是减小链表的长度），JDK7在计算hashCode时做了一些优化。到了JDK8，不再对hashCode做过多的处理，而是"),s("strong",[a._v("在链表长度大于8时，将链表转换为红黑树")]),a._v("。")]),a._v(" "),s("p",[a._v("不过按照网上的说法，JDK8引入红黑树之后，在多线程并发条件下仍然会有死循环。总之，"),s("strong",[a._v("HashMap不是线程安全")]),a._v("的。")]),a._v(" "),s("p",[a._v("由于HashMap在寻址时要用到hashCode方法，如果两个对象hashCode相同，而equals方法返回false，那会导致HashMap里边的两条记录是链表形式，寻址性能不好。equals方法返回true时，hashCode必须相同；hashCode相同时，建议equals方法返回true（非强制）。")]),a._v(" "),s("h2",{attrs:{id:"threadlocal的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal的实现原理"}},[a._v("#")]),a._v(" ThreadLocal的实现原理")]),a._v(" "),s("p",[a._v("ThreadLocal使得每个线程都拥有一份自己的局部变量拷贝，从而规避多线程竞争资源的问题，对外暴露set和get方法。")]),a._v(" "),s("p",[a._v("在继续探索ThreadLocal的原理之前，其实可以自己想一想如何实现，比如我当初想的是内部保存一个数组，为每个线程保存一份竞争资源的拷贝。")]),a._v(" "),s("p",[a._v("如果ThreadLocal内部是数组，无法判断线程和元素之间的所属关系，所以map应该是更合适的数据结构。更进一步，多线程访问ThreadLocal内部的map，那这个map应该用ConcurrentHashMap。ConcurrentHashMap在链表头为null时用cas机制来保证并发安全，但是链表头不为null时会用synchronized加锁。")]),a._v(" "),s("p",[a._v("有了以上的思考，再来结合源码看看JDK是如何做的。")]),a._v(" "),s("p",[a._v("当"),s("code",[a._v("new ThreadLocal<T>()")]),a._v("的时候其实什么也没做，真正的逻辑在set和get方法中。看set的源码：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),a._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadLocalMap")]),a._v(" map "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("map "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("createMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("getMap的源码：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadLocalMap")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),a._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("threadLocals"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("可见ThreadLocalMap是Thread的成员，而不是之前我想的ThreadLocal的成员，这就避免了多线程访问map的问题。重点是这句"),s("code",[a._v("map.set(this, value);")]),a._v("，其中的this是ThreadLocal的实例，也就是一个类里边有n个ThreadLocal的变量，线程内部的map的size就为n。")]),a._v(" "),s("p",[a._v("从上面的代码可知，当map为null时，调createMap创建：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("createMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),a._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),a._v(" firstValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("threadLocals "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadLocalMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" firstValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadLocalMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadLocal")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" firstKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" firstValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    table "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("INITIAL_CAPACITY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" firstKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("threadLocalHashCode "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("INITIAL_CAPACITY "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("firstKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" firstValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    size "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("setThreshold")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("INITIAL_CAPACITY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),s("p",[a._v("jdk对ThreadLocalMap的注释：ThreadLocalMap是一种特别定制的hash map，专门用于维护thread local变量。没用暴露任何操作到ThreadLocal以外。这个类是package private级（就是default，本包可访问）的访问权限，主要是为了能够让Thread类访问到。为了能够支持大规模、长时间的使用，Entry针对key使用了WeakReference。然而，由于没有用引用队列，稳定的Entry只有在哈希表"),s("code",[a._v("starts running out of space")]),a._v("时才能保证被删除。")])]),a._v(" "),s("p",[a._v("Entry的源码：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadLocal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/** The value associated with this ThreadLocal. */")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadLocal")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        value "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("到这里就又尴尬了，因为自己还不熟悉WeakReference，继续翻译jdk的注释：")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),s("p",[a._v("一般一个对象如果有引用，就不会被垃圾回收，而弱引用不会阻止其引用的对象被终止和回收。弱引用主要用来实现canonicalizing mappings。")]),a._v(" "),s("p",[a._v("想象一下GC在某个时间点确定对象是弱可达的，在那个时间点GC将原子的清除所有该对象的弱引用，以及从该对象引用链可达的 任何弱可达的其他对象的所有弱引用。同时，GC将标记上述的那些弱可达的对象为可终止的。同时或稍后，GC会将刚刚那些注册到引用队列的-清除的弱引用-入队。")])]),a._v(" "),s("p",[a._v("这个jdk的注释不容易读懂，特别是它还描述了GC的处理过程。借鉴"),s("a",{attrs:{href:"https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/9-WeakHashMap.md",target:"_blank",rel:"noopener noreferrer"}},[a._v("详解WeakHashMap"),s("OutboundLink")],1),a._v("的白话来描述吧：")]),a._v(" "),s("blockquote",[s("p",[a._v("我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的**“有效引用”并不包括弱引用**。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。")])]),a._v(" "),s("blockquote",[s("p",[a._v("WeekHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。")])]),a._v(" "),s("p",[a._v("显然ThreadLocalMap使用弱引用并不是为了做缓存，而是为了便于线程终止的时候map中的key能够被GC回收。而在线程运行时，ThreadLocal实例一般都有强引用，不会被GC回收。")]),a._v(" "),s("p",[a._v("开篇推荐的文章提到：虽然map中key被回收了，但值还是强引用，entry也还在，无法被GC回收。针对该问题，ThreadLocalMap 的 set 方法中，通过 replaceStaleEntry 方法将所有键为 null 的 entry 的值设置为 null，从而使得该值可被回收。另外，会在 rehash 方法中通过 expungeStaleEntry 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。通过这种方式，ThreadLocal 可防止内存泄漏。")]),a._v(" "),s("p",[a._v("不过这最后一段话自己不太理解，主要是搞不清楚GC和set、rehash的执行先后顺序。")]),a._v(" "),s("p",[a._v("最后，一般使用ThreadLocal都会定义成public static。")]),a._v(" "),s("p",[a._v("后记：等到两个月后学习了netty利用弱引用检查内存泄露之后，就能理解ThreadLocalMap的防内存泄露机制了，原理是一样的。")])])}),[],!1,null,null,null);t.default=e.exports}}]);