(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{229:function(t,n,s){t.exports=s.p+"assets/img/1.3c0c27c3.png"},230:function(t,n,s){t.exports=s.p+"assets/img/2.fb260746.png"},329:function(t,n,s){"use strict";s.r(n);var e=s(0),r=Object(e.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"外观、享元、组合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#外观、享元、组合"}},[t._v("#")]),t._v(" 外观、享元、组合")]),t._v(" "),e("p",[e("strong",[t._v("外观模式")])]),t._v(" "),e("p",[t._v("外观（Facade）模式：通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问。\n"),e("img",{attrs:{src:s(229),alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("享元（flyweight）")])]),t._v(" "),e("p",[t._v("不管叫享元、蝇量都不好理解，自己取名叫“轻量模式”。\n轻量模式和原型模式有相同点，两者都是解决创建大量相同或相似对象的问题，但做法不同，前者是提取共性只创建一个对象而把不同的部分放到别的类中，后者是真的会创建很多相同的对象。\n《head first》在附录中对享元模式的讲解非常简单。\n"),e("img",{attrs:{src:s(230),alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("组合")]),t._v("\n不仅仅是部分和整体，而且单个对象和组合对象具有一致的对外接口。\n跳过透明式的组合模式，只需要5分钟看一下uml图和应用实例就清楚了（重点是那个例子）。\nhttp://c.biancheng.net/view/1373.html")])])}),[],!1,null,null,null);n.default=r.exports}}]);