(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{224:function(t,s,n){t.exports=n.p+"assets/img/1.d1f7cf1e.png"},225:function(t,s,n){t.exports=n.p+"assets/img/2.fadcfc2e.png"},226:function(t,s,n){t.exports=n.p+"assets/img/3.da2c7a6a.png"},227:function(t,s,n){t.exports=n.p+"assets/img/4.4291dbc3.gif"},228:function(t,s,n){t.exports=n.p+"assets/img/5.690ac910.gif"},330:function(t,s,n){"use strict";n.r(s);var a=n(0),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"桥接、装饰"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#桥接、装饰"}},[t._v("#")]),t._v(" 桥接、装饰")]),t._v(" "),a("p",[a("strong",[t._v("桥接（Bridge）模式")])]),t._v(" "),a("p",[t._v("将抽象与实现分离，使它们可以独立变化，是用组合关系代替继承关系来实现。\n"),a("img",{attrs:{src:n(224),alt:""}})]),t._v(" "),a("p",[t._v("上图太抽象了，而且把refined翻译成扩展更不容易理解。\n自己的理解：抽象化角色就是汇总，实现化角色就是某个变量。下面的实例更好理解：\n"),a("img",{attrs:{src:n(225),alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("装饰模式")])]),t._v(" "),a("p",[t._v("在不改变现有对象结构的情况下，动态地给该对象增加一些功能。\n又一次用了组合，和代理、适配器、桥接又有什么本质区别呢？\n星巴兹咖啡店：具体构件有house blend、dark roast、decaf、espresso，具体装饰有蒸奶、豆浆、 摩卡或覆盖奶泡\n"),a("img",{attrs:{src:n(226),alt:""}})]),t._v(" "),a("p",[t._v("(1) 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件，其结构图如图 4 所示。\n"),a("img",{attrs:{src:n(227),alt:""}})]),t._v(" "),a("p",[t._v("(2) 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并，其结构图\n"),a("img",{attrs:{src:n(228),alt:""}})])])}),[],!1,null,null,null);s.default=e.exports}}]);