(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{231:function(t,s,n){t.exports=n.p+"assets/img/1.e3774315.png"},232:function(t,s,n){t.exports=n.p+"assets/img/2.73d198ed.png"},233:function(t,s,n){t.exports=n.p+"assets/img/3.2e0fb3fb.png"},328:function(t,s,n){"use strict";n.r(s);var r=n(0),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"模板、策略、命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模板、策略、命令"}},[t._v("#")]),t._v(" 模板、策略、命令")]),t._v(" "),r("p",[r("strong",[t._v("模板方法")])]),t._v(" "),r("p",[t._v("定义一个抽象类，包含模板方法（汇总）和基本方法，基本方法有抽象类实现的，也有留给子类实现的。\n"),r("img",{attrs:{src:n(231),alt:""}})]),t._v(" "),r("p",[r("strong",[t._v("策略")])]),t._v(" "),r("p",[t._v("定义一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。\n其实就是面向接口编程的应用。在head first的鸭子例子中，策略有两种：fly行为和quack行为，而鸭子就是环境类，拥有这两种行为，\n对于fly行为来说，策略有会飞和不会飞，对quack行为来说，策略有呱呱叫、吱吱叫和不会叫。\n"),r("img",{attrs:{src:n(232),alt:""}})]),t._v(" "),r("p",[r("strong",[t._v("命令")])]),t._v(" "),r("p",[t._v("解耦命令的发送和处理，典型应用是对命令做“撤销、重做、记录”。\n怎么实现呢？\n将请求封装为对象，发出请求的调用者和执行请求的处理者通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。\n调用者持有命令对象，命令对象持有处理者。\n"),r("img",{attrs:{src:n(233),alt:""}})])])}),[],!1,null,null,null);s.default=e.exports}}]);