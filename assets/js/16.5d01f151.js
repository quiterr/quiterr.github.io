(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{238:function(t,e,s){t.exports=s.p+"assets/img/1.f00aeeb2.png"},239:function(t,e,s){t.exports=s.p+"assets/img/2.b00ac829.gif"},240:function(t,e,s){t.exports=s.p+"assets/img/3.544bee76.png"},325:function(t,e,s){"use strict";s.r(e);var n=s(0),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"迭代器、访问者、备忘录"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#迭代器、访问者、备忘录"}},[t._v("#")]),t._v(" 迭代器、访问者、备忘录")]),t._v(" "),n("p",[n("strong",[t._v("迭代器")])]),t._v(" "),n("p",[t._v("迭代器是为了把遍历集合的逻辑抽离出来，学习的时候最大的疑问就是抽离出来之后，两者是怎么关联起来的？\n其实就是集合依赖了迭代器，迭代器是从集合中getIterator出来的（内部new一个，传入集合内容，注意集合类内部是有一个Object[] list来保存数据的）。\n"),n("img",{attrs:{src:s(238),alt:""}})]),t._v(" "),n("p",[n("strong",[t._v("访问者")])]),t._v(" "),n("p",[t._v("被处理的数据元素相对稳定而访问方式多种多样的数据结构，适合用“访问者模式”来处理。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。\n访问者模式包含以下主要角色。")]),t._v(" "),n("ol",[n("li",[t._v("抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。")]),t._v(" "),n("li",[t._v("具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。")]),t._v(" "),n("li",[t._v("抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。")]),t._v(" "),n("li",[t._v("具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。")]),t._v(" "),n("li",[t._v("对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。\n"),n("img",{attrs:{src:s(239),alt:""}})])]),t._v(" "),n("p",[n("strong",[t._v("备忘录")])]),t._v(" "),n("p",[t._v("用来保存对象的状态，例如游戏的状态。\n发起者（Originator）拥有状态、可以创建备忘录（Memento）（把状态放进备忘录对象，不保存备忘录）。\n守护者（Caretaker）拥有（保存）备忘录对象，也可以持有一个备忘录对象的数组或栈，这样可以“后悔”多次。\n当状态变更后，要恢复时，发起者从守护者那里取回备忘录、设置状态。\n"),n("img",{attrs:{src:s(240),alt:""}})])])}),[],!1,null,null,null);e.default=r.exports}}]);